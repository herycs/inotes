# 登录系统设计

## 登录流程

一个最简单的登录流程如下：

1. 输入账号、密码（输入）
2. 提交登录请求（点击登录按钮）
3. 服务端校验并返回登录结果（处理）
4. 前端处理响应结果（输出，显示给用户）

但是存在的问题是我们的通讯机制采用的是HTTP协议，这个协议是无状态的，简单来说引发的问题就是如果不做其他处理，服务端并不知道客户端请求是谁发来的，登录没登录，有没有权限等等，也就无法正确处理用户请求

## Cookie-Session机制

其中一个机制就是Cookie-Session

### cookie机制

两个重要属性：domain(域)和path(路径)

- domain:限制cookie可访问的域，也就是通常所说的域名

- path:限制域范围内可访问cookie的路径

    例如：

    ​	cookie的path=/test/，则test/路径下所有页面均可访问cookie

    ​	但是path=/test/path1/时就只有/test/path1/路径下的页面可访问cookie了（可以理解为最长匹配原则）

    ​	虽然每个网站都对用户颁发Cookie，但浏览器会负责对不同网站访问是并不泄露其他网站的Cookie(隐私安全机制，不可跨域)

**维护**

客户端（浏览器）存储并管理包含用户相关信息的Cookie

**请求**

当请求Server时带上Cookie（http头部保存Cookie），服务端通过解析Cookie中数据实现对请求的识别

**安全**

http传输是存在安全隐患的，Cookie可采用secure=true的设置要求浏览器在安全协议下传输Cookie

**优点**

相对于完全无状态，增加了Cookie后交互行为有了可识别的状态

**问题**

如果只用Cookie可以吗？

简单使用好像没有问题，但是Cookie是在本地的，你是可以设置过期时间什么的，但是Cookie被拿到手解析成功了的情况下用户的相关数据就被窃取了，这是存在很大风险的

### Session机制

与Cookie机制相对应，这是在服务端的处理策略

客户端发起请求之后，服务端将一些信息以Session（会具有唯一的SessionID）的形式封装起来存储在服务器上，并将SessionID反馈给客户端

**维护**

由服务端进行存储与维护

**请求**

当客户端请求时将SessionID包含在请求中发给服务器，服务器依据客户端请求中的SessionID获取到Session，并依据Session中的信息决定对这次请求的处理

**安全**

相对于直接将相关数据存储在Cookie中少了被截获的风险，而且Cookie中的数据也只有SessionID，一定程度上稍微安全一点

至此一个较为成熟的登录机制已经构建完成了（Cookie-Session）机制可以理解为对Http的无状态的一个扩展

**问题**

Cookie-Session配合使用可以完成对用户登录状态的保持，但是Session是存放在服务端的，用户量访问量大了之后还是会影响服务器性能的

### 弊端

1. Session开销大：存储于服务端占用资源
2. 可扩展性：Session存储于内存中可扩展性并不好
3. 跨域操作：跨域操作若处理不当，使用Session的这种机制很可能会拒绝操作

## Token机制

针对Cookie-Session的弊端，以及Web，移动应用的越发流行，这种机制的弊端的影响也变成了必要解决的问题

**流程**

登录

1. 用户登录：用户名，密码以及认证信息（如果有的话）
2. 登录响应：登录信息验证，成功则生成Token，并返回给客户端
3. 存储Token：客户端存储Token

请求

1. 请求：携带Token发起请求
2. 验证并处理：服务端验证Token并作出响应

**优势**

无状态、可扩展

正因为Token的无状态性，扩展时非常方便

**安全性**

可以有效的防止CSRF（跨站请求伪造）

## SSO

全称是Single Sign On，单点登录，简单说就是一个地方登录，其他相关地方使用时不必再次登录

