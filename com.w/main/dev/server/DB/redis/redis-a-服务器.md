# Redis服务器

责任：与客户端建立连接 | 处理客户端发送的命令请求 | DB中维持执行命令而产生的数据 | 资源管理维持服务器的运转

## 命令请求执行过程

1. 客户端向服务端发送命令请求
2. 服务端接收到客户端的命令请求
3. 服务器恢复OK给客户端
4. 客户端接收到响应，显示给用户

### 命令发送：

用户-》客户端-》服务器

用户键入命令，客户端处理用户命令并转换为协议格式发送

### 读取命令：

> 当接收到命令，则套接字变为可读，服务器调用请求处理器处理

1. 读取套接字中协议格式的命令请求，将其保存到*客户端*状态的**输入缓冲区**中
2. 分析**输入缓冲区**中内容，提取命令参数，参数个数分别存储到argv与argc中
3. 调用**命令执行器**，执行客户端指令

### 命令执行器

#### 查找命令

依据argv[0]在命令表中查找定位命令

命令表格式

```c
struct redisCommand redisCommandTable[] = {
    {"module",moduleCommand,-2, "admin no-script", 0,NULL,0,0,0,0,0,0},
    
    {"get",getCommand,2, "read-only fast @string", 0,NULL,1,1,1,0,0,0},
    //...
}
```

依次是：

name：char* 命令名称

proc：redisCommandproc* 函数指针

arity：int 命令参数个数

sflags：char* 命令参数属性，写？读？载入数据时是否可用？等等

- w---写,r---读,m---会占用大量内存,a---管理命令save等,p---发布订阅命令,s---不可以在lua脚本中使用,R---随机命令,S---lua脚本中使用时所得结果需要排序,l---服务器载入数据阶段可以使用,t---服务器带有过期数据时可以使用，M---监视器模式下不会被自动传播

flags：int 对sflags分析得出二进制标志位

calls：long long 服务器执行此命令多少次了

milliseconds：long long 服务器执行这个命令耗费的总时长

#### 执行预备操作

截止目前，对于本次命令请求已有：命令执行函数，命令参数，参数个数的信息

此阶段执行预备操作，确保命令执行环境可以正确、顺利执行命令

1. 命令合法性：
    - 检查命令指针为null，则用户使用命令不存在，返回错误
    - 依据arity属性检查命令个数
2. 权限：
    - 检查客户端是否通过身份验证，未通过只可以执行auth命令，若执行其他命令则返回错误
3. 服务器当前状态
    - 服务器开启memory，则执行前检查内存，有必要时先回收内存再执行命令
    - 服务器上一次执行bgsave错误，且开启了stop-wirites-on-bgsave-error，且服务器要执行写命令则拒绝执行此次命令
    - 客户端在订阅频道或者模式
    - 服务器在执行数据载入
    - 服务器再执行lua超时导致进入阻塞状态
    - 客户端在执行事务，exec，discard，multi，watch，其他命令放入事务队列
    - 服务器打开监视器功能

#### 执行

调用命令执行函数

#### 后置操作

- 慢查询开启：慢日志查询模块会检查是否需要为刚刚命令执行增加慢日志记录
- 依据执行情况：更新执行总时长&执行次数
- 开启持久化：AOF模块将命令写入更新缓冲区
- 集群：当前服务器正在被复制，则将命令传播给其他服务器

至此执行过程完成，从文件事件处理器取出事件处理

### 命令传播

命令实现函数将命令保存到客户端状态**输出**缓冲区中并为客户端关联**命令回复处理器**

客户端套接字变为可写状态时，执行命令恢复处理器，将命令回复发送给客户端

## serverCron函数

默认100毫秒执行一次，负责管理服务器的资源，保持服务器自身的良好运转

### 更新时间

redis中为了减少获取时间调用系统调用，使用时间缓冲

故而时间不精确，应用场景：打印日志，更新服务器LRU时钟，决定是否执行持久化任务，计算服务器上线时间

精确类型：键过期的时间检查，添加慢查询日志，**会再次调用系统调用确保时间的准确性**

### 更新LRU时钟

每个redis对象也有lru时间，对象空转时间 = server时间 - 对象的lru时间

```c
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or LFU data (least significant 8 bits frequency and most significant 16 bits access time). */
    int refcount;
    void *ptr;
} robj;
```

### 更新内存峰值

每次执行更新内存峰值，内存峰值 = max(last峰值，curr峰值)

### 处理sigterm

启动服务器时，Redis会为服务器进程的sigterm信号关联信号处理器sigtermHandler

每次调用函数会检查shutdown_asap属性检查，依据属性值决定是否关闭服务器，服务器接收到关闭之后会先执行RDB持久化

### 管理客户端资源

调用clientsCron，若C-S连接超时-》释放客户端，若上次client命令执行后输入缓冲区大小超过限制-》释放当前缓冲区，创建新的默认大小缓冲区

### 管理数据库资源

对数据库进行检查，删除其中过期键，有需要时进行字典收缩

### 执行延迟命令

BGREWRITEAOF

若BGSAVE执行期间，接收到命令BGREWRITEAOF，则会延迟到BGSAVE执行后再执行

### 检查持久化运行状态

rdb_child_pid | aof_child_pid 分别是bgsave&bgrewriteaof子进程的ID

其中有一个不为 -1 则调用write3函数，检查子进程是否有信号发来服务器进程

- 有信号：新的RDB文件已经执行完毕，用新RDB替换旧RDB，新AOF替换旧AOF
- 没有信号：持久化未完成，不作动作

都为-1

- BGREWRITEAOF是否被延迟
- 自动保存条件是否被满足
- AOF重写是否被满足

### AOF Buffer -> AOF文件

服务器开启AOF，且AOF buffer有东西，则写入文件

### 关闭异步客户端

输出缓冲区超出限制的客户端

### 增加cronloops值

这个值记录了serverCron执行次数

## 初始化

### 创建实例

initServerConfig()调用初始化一般属性，设置运行ID，运行频率，默认配置文件路径，运行架构端口号，持久化条件，初始化LRU时钟，创建命令表

### 载入配置

载入新配置

### 初始化服务器数据结构

目前只有命令表一个数据结构，除此之外还有其他运行的必要数据结构

执行initServer初始化数据结构

- Client链表
- 数据库数组
- 频道订阅信息链表，模式订阅信息链表
- lua执行环境，server.lua
- 慢查询日志相关属性

### 还原数据库

有AOF，使用AOF还原

没有AOF，使用RDB还原

### 执行事件循环

等待客户端请求来临