# BitMap

## 基础操作

setbit [name] [offset] [value]

```shell
127.0.0.1:6379> setbit bit 1 1 # 0000 0010
(integer) 0
127.0.0.1:6379> setbit bit 3 1 # 0000 1000
(integer) 0
```

getbit [name] [offset]

获取一定偏移量上的值

bitcount

统计比特位为1的个数

bitop

```shell
127.0.0.1:6379> setbit x 3 1 # 0000 1000
(integer) 1
127.0.0.1:6379> setbit y 2 1 # 0000 0100
(integer) 1
127.0.0.1:6379> setbit z 0 1 # 0000 0001
(integer) 1
127.0.0.1:6379> bitop and a x y # a = 0000 0000
(integer) 1
127.0.0.1:6379> bitop or b x y # b = 0000 1100
(integer) 1
127.0.0.1:6379> bitop xor c x y # c = 0000 0101
(integer) 1
127.0.0.1:6379> bitop not d z # d = ~(0000 0001) = 1111 1110
(integer) 1
127.0.0.1:6379> bitcount d
(integer) 7
```

## 实现

存储采用SDS，二进制安全

C中对字符串类型读取采用'\0'作为结束位置，若中间出现了这样的字符，则数据读取就出错了

而Redis中以长度len为准判定结束位置，不会受影响，写入和读取是一致的，故二进制安全

另外存储时 bit 字符串是逆序存放的，可以简化setbit命令的实现

### getbit

byte = offset / 8，bit = offset % 8 + 1

依据上述两个值确定位的值

### setbit

由于bit逆序存放，当发生位扩展后不必修改原有的值

### bitcount

#### 遍历

遍历所有位 为1 则计数自增 1

#### 查表算法

对每一种位状态记录，查表得出所有结果

例如8位:

0000 0000	0

0000 0001	1

0000 0011	2

#### 二进制位统计算法

32位值算法实现

```c
swar(int i) {
    
	i = (i & 0x55555555) + ((i >> 1) & 0x55555555); // 5 = 01, 2 -> 1,结果所有bit位和向左进一位
    
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333); // 3 = 0011, 4 -> 2，结果所有bit位和向左进

    i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F); // 0F = 0000 1111, 8 -> 4

    i = (i * 0x01010101) >> 24; // 将8bit为一组的所有的汉明重量记录在最高8位
	
    return i;
}
```

#### Redis实现

未处理位数大于128则调用四次swar算法计算128个二进制位的汉明重量

若未处理数量小于128则使用查表法计算二进制位汉明重量

### Bitop

基于C语言对位的操作