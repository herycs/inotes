# 操作系统内存管理

## 物理地址？

直接使用物理地址用于程序运行并不十分合适

1. 越界很容易导致问题
2. 多程序并发不容易

## 并发下的隔离

并发程序同时处于内存中互不影响需要解决的问题：保护 + 重定位

两个进程的地址28,28如何定位到物理地址不同的地方？

动态重定位：进程空间映射到不同的物理空间

- 实现：基址寄存器 + 界限寄存器
- 缺点：执行时每次都需要 内存地址 + 基址，都有加法和比较的操作，进位传递也需要耗时间

交换技术：交换容易导致内存的碎片化，处理使用的是将进程尽可能向下移动，这个策略成为“内存紧缩”

新问题，动态增长的内存空间？

程序段：向下，数据段：向上，由两端向中间增长

## 空闲内存管理

### 位图

含义：0-空闲，1-占用

缺点：分配空间时存储管理器必须要搜索位图，找到连续k个0的空间

### 链表

分配算法：

1. 首次适配算法
2. 下次适配算法：每次找到合适空间后记录当前位置（仿真程序表明下次适配性能略低于首次适配）
3. 最佳适配算法：会搜索整个链表，比1,2浪费更多内存（生成大量小空闲区）
4. 最差适配算法：首先使用大的空闲区
5. 快速适配算法：为常用大小的空闲区维护单独链表，这使得在查找指定大小的空闲区时很快

## 虚拟内存

基本思想：程序有地址空间，这个空间分成很多块（每一块称为“页”，拥有连续的地址范围），程序运行时若引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，若引用到未在内存中的页时，操作系统负责将缺失的部分装入内存，并重新执行失败的指令。

目的：缓解内存紧张，并提供给应用程序逻辑上连续的空间

### 分页

地址产生：索引，基址寄存器，段寄存器或其他方式

不适用虚拟内存：系统直接将虚拟地址送到总线上，读写具有相同地址的物理内存字

使用虚拟内存：虚拟地址送往（MMU，memory management unit），MMU负责将地址映射为物理地址

#### 页表

虚拟地址由虚拟页号（高位）和偏移量（低位）组成

虚拟页号可以用作页表的索引，找到虚拟页面对应的页表项，通过页表项找到页框号，页框号拼接到虚拟地址的高位端替换掉虚拟页号

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200803083026899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDcwMTc5,size_16,color_FFFFFF,t_70)

访问位：读写操作，OS都会修改这个页，用于在缺页中断时选择要被淘汰的页面

修改位：硬件操作，页被改动后这个标志位用于表明该页是脏页

保护位：表明页运行什么类型的操作（读，写，执行）

高速缓存禁止位：对于设备类型的的访问应当是实时的而不是缓存的状态

### 优化

方向：

1. 映射速度
2. 内存很大-》页表项多-》页表大

#### 1-》转换检测缓冲区

> 实际使用中，对页的访问往往是比较集中而不是全部页

为虚拟页到物理页的映射设计专门硬件设备（称为translation lookaside buffer,TLB，也称相联存储器)，通常在MMU中，包含少量的页表项

工作过程：

虚拟地址放入MMU转换，硬件比对虚拟页号与TLB中表项（并行）

1. 找到匹配的且相关访问条件满足则将页表框直接取出，不必访问页表，若TLB中确实存在，但访问条件异常，例如只读页进行写操作，这会产生保护错误
2. 未检测到匹配项，则进行正常页表查询，并替换到TLB中

当一个表项从TLB中剔除将修改位复制到内存中的页表项，除了访问位，其他值不变

当一个表现从页表加载入TLB时，所有值来自于内存

上述操作，只有内存中没有找到页表项才会陷入到操作系统中

#### 软件TLB管理

软件显示装载TLB，访问失效时，生成一个TLB失效并将问题交给OS，OS找到页面，从TLB中删除项，装载新项，再执行出错指令

### 失效

软失效：表项在内存中

硬失效：表项不在TLB中，也不再内存中

### 2-》大内存

#### 多级页表

目的：避免把页表一直保存在内存中

#### 倒排页表

实际内存中每一个页框有一个表项，而不是每一个虚拟页面有一个表项

表项记录（n, p)，n是进程，p代表虚拟页面

但这种情况下n访问p时不能简单的将p当做指向页表的索引查找物理页框，需要进行转换，而这种情况每次都要发生

解决方法：TLB

![image-20200803090643819](C:\Users\ANGLE0\AppData\Roaming\Typora\typora-user-images\image-20200803090643819.png)

## 置换算法

### 最优页面置换算法

若一个页面需要很多个指令后才会被访问，则晚点装载

缺点：无法实现

### 最近未使用页面置换算法

每个页面两个状态位，访问、修改当前页是修改R位，写入时设置M位，表项中

若硬件不支持，则软件实现，启动一个进程时，设置所有页面都不在内存中，一旦访问某一个页面就会引发缺页中断，修改页表项将其指向正确的页面，设置为ReadOnly，重新启动引起中断的指令

R位可以定期清零用来区别最近被访问的和没有被访问的

缺页中断触发，页面依据R,M分为4类

### 先进先出页面置换算法

但是可能会将最频繁使用的页面置换出去

### 二次机会页面置换算法

寻找最近时钟间隔以来没有被访问过的页面

检查最老页面的R位，R位若是0，页面放入到链表尾端

### 时钟页面置换算法

R位是零则替换为新页面，不是0，则置为0，查看下一个页面

### 最近最少使用页面置换算法

last recently used，LRU，完全实现需要在内存中维护所有页的链表，最近最多使用的页面在表头，最近最少使用的在表尾，但每次更新都需要修改整个页面

### 老化算法

NRU，not frequenctly used，最不常用算法，每个页面关联一个计数器，每次缺页中断产生则将R位的值增加到计数器上，放弃计数器最小的页面

缺点：不遗忘，第一次计数器非常高，第二次计数器值也会高，这会导致可能将常使用页面放弃掉（因为第二次频繁访问量没有第一次大时，仅仅依靠计数器比较，还是会认为，当前页面是不频繁访问的，但事实并非如此）

改进：R位被加之前计数器右移一位，R位加到计数器最左端位不是最右端的位，称为老化算法

### 工作集页面置换算法

工作集：一个进程当前正在使用的页面的集合

## 设计问题

### 局部，全局分配策略

### 负载控制

### 页面大小

### 分离指令空间&数据空间

### 共享页面

### 内存映射文件

### 清除策略

### 虚拟内存接口

## 分段

逻辑实体

段的长度并不相同，运行期间可以动态变化

### &分页结合

MULTICS

地址构成：段 + 段内地址（页号 + 页内的字）

### 工作集时钟算法