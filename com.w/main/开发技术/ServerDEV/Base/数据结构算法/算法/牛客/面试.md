# dp尝试模型（80%题目）

左往右尝试模型

范围尝试模型

样本一个做行一个做列的模型

分支渐进模型

# 二分

旋转数组最小数字

1. 数组元素不重复，前 n > 0个数字进行了旋转
2. 数组元素不重复，前 n = 0个数字进行了旋转
3. 数组元素重复（顺序查找）

# 位运算

二进制中1的个数

1. 右移数字和1与，统计结果（当数字是个负数会导致移到最后变成0xffffffff，而陷入死循环）

2. 数字和1与，统计结果（而后1左移，再次运算）

    缺点循环次数是数字位数

3. 整数-1与整数本身与结果是原整数最右边的1变成0，那么整数有多少个1就可以进行多少次运算

    每次的结果是最右边的1变成0，直至最后一个1变成0

测试用例:

1. 正数：1，0x7FFFFFFF
2. 负数：0x80000000，0xFFFFFFFF
3. 0

# 链表

## 二叉排序树双向链表转换

递归，处理左子树，右子树，再处理根节点

## 复杂链表的复制

思路：原链表，a->b->c，复制后a->A->b->B->c->C

连接：偶数位置是原链表，奇数位置的就是复制后的链表

# 字符串排列

## 求给定字符串的排列

递归，先固定一个字符，再固定后续字符

## 求给定字符串的组合

递归，组合的定义是ab和ba是同一个组合，不同的排列

## 求n个字符的长度为1,2,...,n的组合

## 8个数字放置到正方形的8个顶点上

要求，三组相对的面的和相等

思路，得出数字所有排列，而后一一判定是否符合要求

## n后问题

# 数组

## 数组中出现超过一半的数字

1. 排序后取中间值

2. 两个统计值，一个保存上一次的数字，一个保存重复次数

    后一个数字和上一个相等，重复次数++

    后一个和上一个不等，重复次数--

    次数为0，修改保存数值为后一个数字，次数设置为1

## 最小的K个数

思路1：排序后获取前k个数O(nlogn)

思路2：输入数组可变，基于快排算法排序得到前k个数O(n)

思路3：**海量数据**，使用大小为k的容器

1. 容器未满时，增加数据
2. 容器已满时替换数字，若数字大于当前最大值，则直接放弃掉（不可能是最小k个数中的最小数）

实现机制：容器可以使用最大堆实现（面试手写最大堆有点麻烦，获取最大值O(1),删除和修改O(n*logk)），红黑树（可以询问是否可以使用现成的结构,插入删除O(logk)）

## 连续子数组最大和

遍历：更新当前和的最大值，若之前和小于当前值，则更新数组为从当前值开始的，若当前值导致和减小，则跳过当前值

动态规划：f(i) 

- data[i]  当(i = 0, f(i - 1) <= 0)
- f(i - 1) + data[i]  当i != 0,f(i - 1) > 0

## 1-n整数中十进制1出现的次数

思路：每次去掉最高位做递归，数字分段，21345分为 1~1345 和 1346 ~ 21345递归使得其子位变为1求出出现次数

时间复杂度O(logn)

## 数组排成最小数

隐形大数问题，比较两个数的排序后的大小，选出最小的（最优的排列顺序）

# 时间效率和空间效率

## 丑数

丑数应当是另外一个丑数* 2或3或5的结果

思路：已有排序的丑数 * 2，* 3，* 5 求出第一个大于当前已存在的丑数最小的结果

优化，找到丑数 * 2，这个丑数之前的丑数* 2 小于已有的最大丑数，它之后的* 2结果都会太大

## 第一个只出现一次的字符

两次hash,第一次统计出现次数，第二次找到次数为1的

## 删除第一个字符串中，第二个字符串中出现过的所有字符

hash 表存储第二个字符串，遍历第一个字符串，时间复杂度O(n)

## 删除字符串中所有重复出现的所有字符

定义boolean数组，扫描到字符将字符串的ASCII为下标的值置为true，后续通过O(1)即可判定是否出现过

## 变位词

单词字母相同，出现次数也相同

思路：扫描一个字符，使用数组记录其字母出现的次数，扫描第二个字符，对于ASCII下标值--，若结果是所有的值都为0了，则互为变位词

## 逆序对

分解n 分解为两个 n/2 的数组，直到 子数组为1,1长度

分别统计子数组的逆序对，而后合并两个子数组的逆序对（合并后要排序，便于后续的操作）

过程：5,4 7,6，子数组逆序对为1 + 1 = 2， 合并后，4,5,6,7，和后续比较的时候便于查找逆序对

## 两个链表的第一个公共节点

具有公共节点的单链表形状类似于Y型，借助栈实现（时间：O(m+n)，空间：O(m+n)）

获取链表长度（例如分别是， 4,5 ）那么，我们遍历的时候可以让长的先走5 - 4 = 1个结点，然后同步后移，第一个相同的就是目标结点

## 二叉树的深度

## 二叉树是不是平衡二叉树

后续遍历，通过已经遍历的左子树和右子树可以判断子树是否平衡，当遍历到根节点时整个树是否平衡也就得出结果了

## 数组中只出现一次的数字

一个数异或它本身 = 0

子数组分解通过异或的结果拆分数组

## 和为S的两个数字和和为S的正整数序列

思路：双指针

## 翻转单词顺序左旋转字符串

# 优化

## StringBulider进行字符串拼接

## 递归

子问题重复，可以使用递归，但为了减少时间复杂度建议可以的话使用数组记录中间结果，优化时间

## 查找

顺序查找需要O(n)，排序的数组查找需要O(logn)，事先构造了hash表时间复杂度为O(1)

