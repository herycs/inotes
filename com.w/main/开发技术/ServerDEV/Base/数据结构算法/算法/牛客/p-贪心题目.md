# 贪心算法题

## 数组覆盖

> 长度为L的绳子和一个数组
>
> 求绳子最多覆盖其中几个点

1. 定长双指针（right为当前位置，left = [right - L] 指向当前能覆盖的最开始的位置）
2. 快慢双指针（left，right不断后移，维持left 和 right的间距小于 L ）
    1. 当right - left <= L，更新值 right++
        1. right - left > L 保持原有值不更新，这时left 和 right之间覆盖的就是当前情况下的解
        2. left++，循环

## 容器盛水

> 二维数组作为容器，边界不存水
>
> 求解整个数组中能存储多少水量

策略：小根堆（实现对存储空间的选择）辅助

1. 边界入小根堆
2. 选择最低的边界，分别对水量进行考虑
    1. 入堆时若小于当前记录max则水量增加，否则不变
    2. 出堆时，周围未入堆的位置入堆，直至全都入堆
3. 循环

## 删除字符

> 字符串：目标字符串s1, 原字符串s2
>
> 求删除 s2 中的字符最少达到 s1 的值

策略：

1. 子序列，依次使用kmp与s2匹配
2. 删除字符和增加字符效果等同，故通过对s1增加字符变为s2实现对删除字符的选择

## 字符串交错

> 给定：s1, s2
>
> 求解 内否由 s1,s2中字符不变序号情况下交错组成 目标字符串

策略：动态规划

1. dp[i]\[j] 含义 s1 前 i 个字符， s2 前 j 个字符能否组成目标字符
2. 由于目标字符串由 s1 + s2 组成，则最终字符串长度 = s1.length + s2.length，也就是说最终的 dp[i]\[j]就是结果

## 线段重合

排序表TreeMap

弹出所有小于等于当前开始位置的（因为覆盖不到），排序表中存储的是结束的位置，结束位置是否重合确保了能否覆盖

## 打怪兽

依据能力值，金钱，判断如何通关

能力<怪兽，则需要金钱贿赂怪兽

能力>大于怪兽，则可以直接搞定怪兽，也可以使用金币

问题：直到通关最少花费多少钱

策略：二维数组，金钱和能力为行列

## 合并数组

分散的数组段，将其可合并的区间合并