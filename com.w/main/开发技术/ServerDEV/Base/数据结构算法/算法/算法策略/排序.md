# 排序算法

# 选择类

## 1.选择排序

> 第一次查找第1小的放到0号单元
>
> 第二次查找第2小的放到1号单元
>
> 。。。
>
> 总计，查找了n，n-1，n-3, ... , 1
>
> 平均查找：(n / 2)--->总时间复杂度，n * (n / 2) = 1/2 * n^2 = n^2

时间复杂度：O(n^2)

比较方式：保证待排序序列的第一个值为最小值

遍历过程:

1. minPox暂存待排序序列第一个值，作为后续比较基准
2. 依次将待排序序列第2个值到数组结束的所有值拿出与minPox位置处的值比较，minPox在此过程中将永远指向当前已比较的序列中的最小值，当比较结束，minPox指向的就是整个待排序序列的最小值
3. 交换第一个值和minPox索引位置的值

```java
public void selectSort(int[] nums){
    if (nums == null || nums.length < 2) return;

    for (int i = 0; i < nums.length - 1; i++) {//每次选定一个比较基准，[0, len - 1]
        int mixPos = i;//锁定当前最小值索引
        for (int j = i + 1; j < nums.length; j++) {//每次从i的后一个位子开始比较，[i + 1, len]
            if (nums[mixPos] > nums[j])
                mixPos = j;
        }
        if (mixPos != i) SortUtils.swap(nums, i, mixPos);
    }
}
```

## 2.树型选择排序

## 3.堆排序

#  交换类

## 1.冒泡排序

使用两个索引：i, j

[i]指向当前需要存放最小元素的位置

[j]指向当前与[i].value比较的元素

策略：i依次指向数组的每个元素，j负责找出{最小的元素，第2小的元素，，，第n小的元素}，随后交换 i, j 指向的值

**改进**

1. 当比较过程中出现没有交换的情况，则数据已经有序，后续的比较可以免了

    方法：设置标志位，当发生了交换则继续，未发生则跳出循环

    ```java
    boolean flag = true;
    for (int i = 0; i < nums.length && flag; i++) {
        flag = false;
        for (int j = 0; j < nums.length-1; j++) {
            if (nums[j] > nums[j]){
                SortUtils.swap(nums, j, j+1);
                flag = true;
            }
        }
    }
    ```

2. 数组中可能存在有序序列

    方法：增加遍历记录交换发生的最后一次的索引，这个索引记录的就是数组的乱序数组的最后边界

    ```java
    boolean flag = true;// flag = false,则数组已有序
    int arrBound = nums.length - 1;//无序数组边界，默认整个数组均乱序
    int lastSwapIndex = 0;//发生交换的最大边界值
    
    for (int i = 0; i < nums.length && flag; i++) {
        flag = false;
        for (int j = 0; j < arrBound; j++) {
            if (nums[j] > nums[j+1]){
                SortUtils.swap(nums, j, j+1);
                flag = true;
                lastSwapIndex = j;
            }
        }
        arrBound = lastSwapIndex;
    }
    ```

## 2.快速排序

D&C---divide and conquer分而治之

> 最差情况下：O(n^2)
>
> 平均情况下：O(n log n)

```java
/**
* 递归调用
* */
public void qSort(int[] nums, int left, int right){
    if (left >= right) return;
    int mid = partition(nums, left, right);
    qSort(nums, left, mid - 1);
    qSort(nums, mid + 1, right);
}
/**
* 单次快排
*      将范围内数据使用快排策略完成排序，同时返回中间值
* 快排策略：
*      找一个标准，将数组排序为两部分，一部分小于等于这个标准，一部分大于这个标准
*      而后依次在两个分区，同时执行上述算法
* */
public int partition(int[] nums, int left, int rightBound){
    int target = nums[rightBound];
    int right = rightBound - 1;
    while (left <= right){
        while (left <= right && nums[left] <= target) left++;
        while (left <= right && nums[right] > target) right--;
        if (left < right) SortUtils.swap(nums, left, right);
    }
    if (left != right) SortUtils.swap(nums, left, rightBound);
    return left;
}
```



# 插入

## 1.直接插入排序

- 已排序序列中从后向前扫描，找到相应的位置并插入
- 举例：摸牌

```java
private static int[] InsertDirect(int[] data) throws Exception {
        if (data == null)
            throw new Exception("待排序列为空");
        int[] nums  = new int[data.length+1];
        for (int i = 0; i < data.length; i++) {
            nums[i+1] = data[i];
        }

        int i, j;
        for (i = 2; i < nums.length; i++) {
            nums[0] = nums[i];//保存待查数据
            for (j = i-1; nums[0] < nums[j]; j--) {
                nums[j + 1] = nums[j];//记录后移
            }
                nums[j+1] = nums[0];//插入正确位置
        }
        return nums;
    }
```



## 2.折半插入排序

```java
private static void binarySort(int[] nums) {
        int low, height, mid;
        for (int i = 2;  i< nums.length; i++) {
            if (nums[i] < nums[i-1]){
                nums[0] = nums[i];
                low = 1;
                height = i-1;
                while (low <= height){
                    mid = (low+height) / 2;
                    if (nums[0] < nums[mid]){
                        height = mid-1;
                    }else {
                        low = mid+1;
                    }
                }
                for (int j = i-1; j >= low; j--) {
                    nums[j + 1] = nums[j];//后移元素
                }
                nums[low] = nums[0];//插入到正确位置
            }
        }
    }
```



## 3.希尔排序



# 分配类

## 1.多关键字排序

## 2.链式基数排序

# 归并类

## 1.二路归并排序

> O(n * log n)

## 2.自然归并排序

# 外部排序

## 1.置换选择排序

## 2.多路归并外排序

## 