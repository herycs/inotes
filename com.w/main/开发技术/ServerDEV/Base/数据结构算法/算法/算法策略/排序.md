# 排序算法

#  交换类

## 1.冒泡排序

使用两个索引：i, j

[i]指向当前需要存放最小元素的位置

[j]指向当前与[i].value比较的元素

策略：i依次指向数组的每个元素，j负责找出{最小的元素，第2小的元素，，，第n小的元素}，随后交换 i, j 指向的值

**改进**

1. 当比较过程中出现没有交换的情况，则数据已经有序，后续的比较可以免了

    方法：设置标志位，当发生了交换则继续，未发生则跳出循环

    ```java
    boolean flag = true;
    for (int i = 0; i < nums.length && flag; i++) {
        flag = false;
        for (int j = 0; j < nums.length-1; j++) {
            if (nums[j] > nums[j]){
                SortUtils.swap(nums, j, j+1);
                flag = true;
            }
        }
    }
    ```

2. 数组中可能存在有序序列

    方法：增加遍历记录交换发生的最后一次的索引，这个索引记录的就是数组的乱序数组的最后边界

    ```java
    boolean flag = true;// flag = false,则数组已有序
    int arrBound = nums.length - 1;//无序数组边界，默认整个数组均乱序
    int lastSwapIndex = 0;//发生交换的最大边界值
    
    for (int i = 0; i < nums.length && flag; i++) {
        flag = false;
        for (int j = 0; j < arrBound; j++) {
            if (nums[j] > nums[j+1]){
                SortUtils.swap(nums, j, j+1);
                flag = true;
                lastSwapIndex = j;
            }
        }
        arrBound = lastSwapIndex;
    }
    ```

## 2.快速排序



# 插入

## 1.直接插入排序

- 已排序序列中从后向前扫描，找到相应的位置并插入
- 举例：摸牌

```java
private static int[] InsertDirect(int[] data) throws Exception {
        if (data == null)
            throw new Exception("待排序列为空");
        int[] nums  = new int[data.length+1];
        for (int i = 0; i < data.length; i++) {
            nums[i+1] = data[i];
        }

        int i, j;
        for (i = 2; i < nums.length; i++) {
            nums[0] = nums[i];//保存待查数据
            for (j = i-1; nums[0] < nums[j]; j--) {
                nums[j + 1] = nums[j];//记录后移
            }
                nums[j+1] = nums[0];//插入正确位置
        }
        return nums;
    }
```



## 2.折半插入排序

```java
private static void binarySort(int[] nums) {
        int low, height, mid;
        for (int i = 2;  i< nums.length; i++) {
            if (nums[i] < nums[i-1]){
                nums[0] = nums[i];
                low = 1;
                height = i-1;
                while (low <= height){
                    mid = (low+height) / 2;
                    if (nums[0] < nums[mid]){
                        height = mid-1;
                    }else {
                        low = mid+1;
                    }
                }
                for (int j = i-1; j >= low; j--) {
                    nums[j + 1] = nums[j];//后移元素
                }
                nums[low] = nums[0];//插入到正确位置
            }
        }
    }
```



## 3.希尔排序



# 分配类

## 1.多关键字排序

## 2.链式基数排序

# 归并类

## 1.二路归并排序

## 2.自然归并排序

# 外部排序

## 1.置换选择排序

## 2.多路归并外排序

# 选择类

## 1.简单选择排序

时间复杂度：O(n^2)

比较方式：保证待排序序列的第一个值为最小值

遍历过程:

1. minPox暂存待排序序列第一个值，作为后续比较基准
2. 依次将待排序序列第2个值到数组结束的所有值拿出与minPox位置处的值比较，minPox在此过程中将永远指向当前已比较的序列中的最小值，当比较结束，minPox指向的就是整个待排序序列的最小值
3. 交换第一个值和minPox索引位置的值

```java
int minPos = -1;
//每次比较的数值的筛选次数,由于是每次比较2个数n-1
for (int i = 0; i < nums.length-1; i++) {
    minPos = i;//暂存待排序序列第一个位置为最小值索引，以此作为后续序列的比较基准
    //每次检索范围：当前位置之后待排序序列
    //目标：保证当前位置保存待排序序列最小值
    for (int j = i+1; j < nums.length; j++) {
        if (nums[minPos] > nums[j])
            minPos = j;
    }
    if (minPos != i){
        SortUtils.swap(nums, i, minPos);//交换索引i,j位置的值
    }
}
```

## 2.树型选择排序

## 3.堆排序