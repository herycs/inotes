# 算法 - 模式匹配

[TOC]

# 1.串的模式匹配

## 1.1 BF模式匹配算法

- 算法思想：
  - Brute-Froce算法（蛮力算法）
  - 主串的第pos位置开始与模式串T第一个字符开始比较
    - 相等=>比较模式串T后续字符
    - 不等=>回溯到主串的第pos+1，模式串第1个字符继续比较

- 策略：

  - 从前到后依次比较

  - 具体：

    > i--->当前比较的主串中字符的索引，j--->当前比较的模式串中的字符的索引

    - 主串pos位置，模式串第一个位置开始（i = pos, j = 1），比较对应字符
      - 匹配成功=>比较后续字符（i++, j++)
      - 失配=>主串的下一个字符，模式串的第一个字符（i = i-j+2，j = 1）
    - 匹配成功=>返回模式串T的第一个字符在主串中的位置

  - 最坏情况下时间复杂度：O(m*n)，m为主串长度，n为模式串长度

## 1.2 KMP模式匹配算法

- 算法思想：

  - Knuth-Morris-Pratt算法（简称KMP），由D.EKnuth、J.H.Morris和V.R.Pratt提出的改进算法。改进，消除BF算法的回溯，使得算法的时间复杂度是O(m+n)

  - 策略：

    - 当每一趟匹配过程出现了不等时主串S中的 i 指针不回溯，利用已得到的匹配的部分，使得模式串尽可能“滑行”足够远的距离后继续比较

    - 算法借助一个依据模式串生成的 next[] 数组

      > i--->当前比较的主串中字符的索引，j--->当前比较的模式串中的字符的索引

      - 初始化：i = pos，j = 1
      - 字符是否匹配：
        - 匹配=> i++，j++
        - 否则=> i = i，j = next[j]
      - 重复以上步骤直至：
        - j 退到某个 next 值时匹配=>i++,j++，继续匹配
        - j 退到 next[j]=0 =>向右滑动