# 背包问题

背包问题策略实质还是穷举

类似二叉树的方式对每个物品进行选择，递归过程中穷举了所有的状态，而改成动态规划使得其更加可控且凭借数组的O(1)随机访问的特性可以极大的提高算法的执行效率

动态规划解决此类问题，本质上是将递归中的状态保存下来了，而空间等优化就是保留和当前运算有关的状态空间保留，进而减少那些只用一次且后期不会再使用的空间

## 01背包问题

$$
F[i, v] = max(F[i − 1, v], F[i − 1, v − C_i ] + W_i)
$$

设定返回条件，确定函数传递参数

一般是：背包数组，当前索引，价值，容量

初始化时的dp数组状态就是一种合法状态

- 求解恰好装满，f(0) = 0, f(1...n) = -oo，这样只有装满背包才是合法解
- 价格尽量大：f(0...n) = 0，这样只要保证价值尽量大就可以确保其是合法解

优化：

- 时间复杂度无法再进行优化，空间优化每次都只与上次的状态也就是i - 1行的状态有关，故数组可以压缩到一行

    内层循环：for i v->Ci {dp[i] = max(dp[v], dp[v - Ci] + Wi)}

## 完全背包1

每种产品无限件
$$
F[i, v]=max(F[i - 1, v - kC_i] + kW_i | 0 <= kCi<=V)\\O(NV\frac{v}{C_i})
$$
总时间复杂度

## 多重背包

N个物品，背包容量V

第i种，最多Mi件可用，每件耗费Ci，价值Wi
$$
F[i, v]=max(F[i - 1, v - kC_i] + kW_i | 0 <= k<=M_i)\\O(V\sum M_i)
$$

## 混合背包

针对每一个物品选择对应的背包方式

## 二维费用背包

每件物品，两种不同维护费用，选择这件物品必须同时付出这两种费用，每种费用有一个可付出的最大值，如何选择物品可以得到最大值

第i件物品，需要的费用分别为Ci和Di，两种费用可付出最大值为V和U，物品价值Wi

增加一维状态
$$
F[i, v, u]=max(F[i - 1, v, u], F[i - 1, v - C_i, u - D_i] + W_i)
$$

## 分组背包

N个物品，背包容量V

第i种，最多Mi件可用，每件耗费Ci，价值Wi

物品被划分为k组，每组物品相互冲突，最多选一件
$$
F[k, u]=max(F[k - 1, v], F[k - 1, v - C_i] + W_i | item_i(- group_k)
$$

## 依赖背包

选了i物品，j物品必选

## 泛化物品

物品无固定价值，价值取决于当前分配给的费用

对于物品i分配费用v，则价值 = h(v)

泛化物品和h和l
$$
f(v) = max(h(k) + l(v - k) | 0 <= k <= v)
$$

## 背包问题变化

输出方案

输出字典序最小，最优方案

求方案总数

最优方案总数

求次优解，第K优解