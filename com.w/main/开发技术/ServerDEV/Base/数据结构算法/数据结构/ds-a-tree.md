# Tree

## 演进

1. 二叉树
2. 二叉查找树
3. AVL树
4. 红黑树
5. B/B+/B*树

## 二叉树

没有什么特殊限制，保证其每个节点至多有2个子节点即可

## 二叉查找树

> 有称有序二叉查找树，无键值相等点

### 特点

保证其左右节点数值有序，左结点小于其根结点值，右结点值大于根节点值

- 简单来讲就是对任意（参与比较的结点都非空）结点有以下关系：leftData < rootData < rightData

### 优点

查找速度高于顺序查找，（检索次数少了）

### 缺点

特殊情况下，二叉查找树可能会单臂很长，这时其查找长度就会和线性查找逼近

> 单臂长举例
>
> ```shell
>       1
>        \
>         2
>          \
>           3
>            \
>             4
> ```
>
> 这种情况下和线性查找：1,2,3,4相比，效率并没有多少提高。

### 改进

上述单臂长的原因就是根节点始终没有变化过，但实际使用上并不能保证当前的根节点就是最优根节点。

## AVL树

带平衡条件的二叉查找树

> 一般提供一个**平衡因子**，通过保证平衡因子在一定范围，从而保证树当前处于最优状态
>
> 平衡因子超过范围会对树进行旋转（简单来讲就是将树的根节点进行切换），从而尽量降低树的高度，减少查找次数。

### 优点

树的高度尽量降低，从而保证查找效率

### 缺点

维护高度需要对树进行旋转，这个过程是比较耗时的

### 应用

适用于查找删除次数少（调整树的次数尽量少），查询较多的情况（调整后的树查找效率还是比较可人的）

**时间应用场景**

查资料得知：Windows NT 内核中采用

### 改进

主要是修正树的次数过多影响性能，一个改进策略就是减弱对树高的判定从而减少修正次数

## 红黑树

**弱平衡**二叉查找树，每个节点添加一个标记颜色，通过对着色的限制确保没有一条路径长度比其他路径长2倍。

### 优点

通过检测颜色对树进行调整，相对于AVL树而言平衡的要求降低了一点

### 缺点

弱平衡，可能在某些情况下树并非是最优的查找树结构

### 应用

1、广泛用于C++的STL中，Map和Set都是用红黑树实现的； 
2、著名的Linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间； 
3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查； 
4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器； 
5、Java中TreeMap的实现；

## B树

结点的信息量不在单一只有本节点和子节点指针，结点的除了自己的节点数据还有子节点的索引，这样在查找的时候就可用更少的次数选对正确的路径（不许要读取子节点数据{减少了磁盘读取次数}，比对索引就可确认下一个前进的方向）

### 优点

减少IO次数,查找性能更优

### 缺点

结点存储的有数据，这样的话结点数据大索引的数量就会减少，同样读取这种结点也更加耗时一点

### 应用

磁盘文件组织，数据索引，数据库索引

### 改进

单个结点数据量大时索引会减少，且读取这种节点也更耗时（如果这个结点不是目标结点，这个耗时的IO就有点亏了）

## B+树

非叶子节点只有索引，叶子节点存储有数据

### 优点

结点的索引得到保证，大小也得到了保证，这样的话在节点IO层面每个节点的读取耗时相差不会很大

### 缺点

1. 主键非**有序**递增的，导致每次插入数据产生大量的**数据迁移**和**空间碎片**；
2. 主键是**有序**递增的，大量写请求的分布仍是随机的；

## #其他

> [参考资料](https://www.cnblogs.com/tiancai/p/9024351.html)
>
> 推荐阅读：[分形树](https://www.open-open.com/news/view/e89fb0)