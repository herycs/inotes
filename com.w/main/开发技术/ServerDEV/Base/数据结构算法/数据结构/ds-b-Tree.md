# 数据结构-树

## 概述

1. 二叉树
2. 二叉查找树
3. AVL树
4. 红黑树
5. B/B+/B*树

### 二叉树

没有什么特殊限制，保证其每个节点至多有2个子节点即可

### 二叉查找树

> 有称有序二叉查找树，无键值相等点

特点：保证其左右节点数值有序，左结点小于其根结点值，右结点值大于根节点值

- 简单来讲就是对任意（参与比较的结点都非空）结点有以下关系：leftData < rootData < rightData

优点：查找速度高于顺序查找，（检索次数少了）

缺点：特殊情况下，二叉查找树可能会单臂很长，这时其查找长度就会和线性查找逼近

> 单臂长举例
>
> ```shell
>    1
>     \
>      2
>       \
>        3
>         \
>          4
> ```
>
> 这种情况下和线性查找：1,2,3,4相比，效率并没有多少提高。

改进：上述单臂长的原因就是根节点始终没有变化过，但实际使用上并不能保证当前的根节点就是最优根节点。

## AVL树

带平衡条件的二叉查找树

> 一般提供一个**平衡因子**，通过保证平衡因子在一定范围，从而保证树当前处于最优状态
>
> 平衡因子超过范围会对树进行旋转（简单来讲就是将树的根节点进行切换），从而尽量降低树的高度，减少查找次数。

优点：树的高度尽量降低，从而保证查找效率

缺点：维护高度需要对树进行旋转，这个过程是比较耗时的

应用：适用于查找删除次数少（调整树的次数尽量少），查询较多的情况（调整后的树查找效率还是比较可人的）

应用场景：查资料得知：Windows NT 内核中采用

改进：主要是修正树的次数过多影响性能，一个改进策略就是减弱对树高的判定从而减少修正次数

## 红黑树

**弱平衡**二叉查找树，每个节点添加一个标记颜色，通过对着色的限制确保没有一条路径长度比其他路径长2倍。

优点：通过检测颜色对树进行调整，相对于AVL树而言平衡的要求降低了一点

缺点：弱平衡，可能在某些情况下树并非是最优的查找树结构

应用

1、广泛用于C++的STL中，Map和Set都是用红黑树实现的； 
2、著名的Linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间； 
3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查； 
4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器； 
5、Java中TreeMap的实现；

## B树

结点的信息量不在单一只有本节点和子节点指针，结点的除了自己的节点数据还有子节点的索引，这样在查找的时候就可用更少的次数选对正确的路径（不许要读取子节点数据{减少了磁盘读取次数}，比对索引就可确认下一个前进的方向）

优点：减少IO次数,查找性能更优

缺点：结点存储的有数据，这样的话结点数据大索引的数量就会减少，同样读取这种结点也更加耗时一点

应用：磁盘文件组织，数据索引，数据库索引

改进：单个结点数据量大时索引会减少，且读取这种节点也更耗时（如果这个结点不是目标结点，这个耗时的IO就有点亏了）

## B+树

非叶子节点只有索引，叶子节点存储有数据

优点：结点的索引得到保证，大小也得到了保证，这样的话在节点IO层面每个节点的读取耗时相差不会很大

缺点

1. 主键非**有序**递增的，导致每次插入数据产生大量的**数据迁移**和**空间碎片**；
2. 主键是**有序**递增的，大量写请求的分布仍是随机的；

> [参考资料](https://www.cnblogs.com/tiancai/p/9024351.html)
>
> 推荐阅读：[分形树](https://www.open-open.com/news/view/e89fb0)

# BiTree

## 二叉树

- 无其他要求，保证每个结点只有左右两个子结点

## 平衡二叉树

> 一种二叉排序树,每个结点的左子树和右子树的高度差至多等于1

- 二叉树上有一个结点的平衡因子的绝对值大于1，则不平衡

- 对二叉树进行了约束，为了防止出现单边特别长的时候影响查询效率

策略：

增加平衡因子（二叉树上结点的左子树深度减去右子树深度的值称为**平衡因子**BF）

> 结点平衡因子：nodeBF = heightL - heightR

### 建立

距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，称为**最小不平衡子树**。

在插入值的时候同时评价平衡因子
- 若平衡因子大于1，左旋
- 若平衡因子小于-1，右旋

> 对于树的旋转，为了方便调整，结点应包含：数据，指向父结点指针，指向左右子结点指针，深度

### 删除

删除叶子子结点直接删除，检查调整

删除非叶子结点，需要在删除时进行调整，确保树的关系

## 遍历

### 递归

伪代码

```java
void f(Node root){
	if(root != null){
		print(root.data);//1
		f(root.leftNode);//2
		f(root.rightNode);//3
	}
}
//上述三句交换顺序即就是先中后序遍历
//先：123;中：213;后：231
```

### 非递归

策略：使用额外存储空间辅助遍历，例如：列表，栈。

伪代码

```java
void f(Node root){
    //预备存储空间
    Node p = root;//用于在树结点间切换
    ArrayList list = new ArrayList<Node>();//结果集合
    Stack stack = new Stack();//辅助遍历，
    
    //遍历
    while ( !stack.empty() && p != null){
        //[stack.empty() != true]左子树及其结点未遍历完，[p != null]未到根结点
        while(p != null){
            list.add(p.data);//[1]
            {//[2]
                stack.push(p);//将结点保存到栈中，用于遍历其右子树
	            p = p.left;//递归
            }
        }
        while(!stack.empty()){
            //栈非空，则存在右子树或结点
            Node tempNode = stack.pop();//出去栈顶元素
            //[3]
            p = tempNode.right;//将右结点交给p继续遍历
        }
    }
}
//先中续遍历
//先：123
//中：将1放到3的位置处，代码变为list.add(tempNode.data);顺序213
```

策略：

- 先将所有结点遍历到stack中，并将stack2中的标记为左子树
- 若辅助栈元素标记为右子树，则输出结点数据
- 数据栈stack非空，修改标记栈标记为右子树标记，取出数据栈元素对其右子树进行判断，继续继续判断

```java
//后续遍历伪代码
void f(Node root){
    //数据栈
    Stack<BinaryNode> stack1 = new Stack<>();
    //辅助栈
    Stack<Integer> stack2 = new Stack<>();
    int i = 1;//表示为右结点
    while(Node != null || !stack1.empty())
    {
        while (Node != null)
        {
            stack1.push(Node);
            stack2.push(0);
            Node = Node.left;
        }
        //右子树回到根结点，则直接输出
        while(!stack1.empty() && stack2.peek() == i)
        {
            stack2.pop();
            System.out.print(stack1.pop().element + "   ");
        }
        //数据栈非空
        if(!stack1.empty())
        {
            //修改标记
            stack2.pop();
            stack2.push(1);
            //进入当前结点为根的右子树
            Node = stack1.peek();
            Node = Node.right;
        }
    }
}
```

### 层次遍历

- 一层一层的遍历

策略：队列，先是跟结点入队列，然后是根结点出队列，同时此结点的左右结点入队列

```java
如：树123层分别为
		1
	    / \
	   2   3
	  / \  / \
	 4  5  6  7

访问过程队列变化：
1
2 3 //1 out 2,3 in
3 4 5 // 2 out, 4,5 in
4 5 6 7 // 3 out, 6,7 in
```

```java
void f(Node root){
	Queue queue = new Queue();
    if (root == null)return;
    //队列非空，遍历未完成
    while(!queue.isEmpty()){
        	//出队列
			TreeNode temp  = queue.poll();
			System.out.print(temp.val + " ");
        	//左非空入队列
			if(temp.left != null)
				queue.offer(temp.left);
        	//右非空入队列
			if(temp.right != null)
				queue.offer(temp.right);
		}
}
```



# BTree

## B树

### 基础

> 英文中的B-Tree，一个 m 阶的B树满足以下条件：

1. 每个结点至多拥有m棵子树；
2. 根结点至少拥有两颗子树（存在子树的情况下），根结点至少有一个关键字；
3. 除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；
4. 所有的叶结点都在同一层上，B树的叶子结点可以看成是一种外部结点，不包含任何信息；
5. 有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；
6. 关键字数量需要满足ceil(m/2)-1 <= n <= m-1；

## B树高度

一棵含有N个总关键字数的m阶的B树的最大高度：
$$
\log_(m/2) \frac{N+1}{2} +1
$$

### 为什么要有B树

**原因**：磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。而文件读取需要先定位到磁盘中的块（这个定位过程耗时是比较大的），而后继续数据读取。若数据量很大，那么数据的读取的耗时是比较大的。

**优化**：B树可以在多结点上存储相关信息，而树的层数也可尽量少，在树种查找结点减少结点的访问次数就减少了磁盘的访问，因而性能得到了提高。

查询稳定，查找时间复杂度是O(log2N)。

### 操作

**插入**

结点关键字没达到m-1，直接插入

结点关键字达到m-1

- 结点需要进行分裂，中间关键字提升到父结点，两边关键字分裂为子结点（若是父结点也达到了m-1则需要载此进行分裂）

**删除**

> 查找值，有则删除

删除后，结点关键字满足B树要求

删除后，结点关键字不满足B树要求，向兄弟结点借关键字
- 兄弟结点关键字足够
    - 借关键字给该结点，父结点下移，兄弟结点上移

### 查找

策略：范围查找采用中序遍历

# B+树

> 对应文件系统而产生的B树的变形

## B+树特征

- 有k个子树的中间结点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来**索引**；
- 所有的**叶子结点**中包含了**全部关键字**的信息，及指向含有这些关键字**记录的指针**，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B树的叶子结点并没有包括全部需要查找的信息)；
- 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终结点也包含需要查找的有效信息)；

## 对B树的升级

1. 磁盘读写代价低

    内部结点只有索引，同样的存储空间存储的结点信息更多，磁盘读取时可使用更少的IO

2. 查询效率稳定

    只有叶子结点才有数据，故查询都得走到叶子结点去获取信息。

3. 适合于范围查找

    数据库而言精确查找是少数，更多的是范围查找，B+树的最终数据信息都在叶子结点，故若要遍历整个树只需要遍历叶子结点即可，范围查找相对于B树而言B+树更加的适合。

## 变化

### 分裂

当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点

## 操作

### 查找

范围查找采用链表，一般会维护一个将所有叶子结点数据连接起来的结点

### 删除

删除后维护树的结构保证树符合基础定义

### 插入

插入后维护树的结构，使其符合B+树的基础定义

## 拓展

- 在数据库的聚集索引（Clustered Index）中，叶子结点直接包含数据。

- 在非聚集索引（NonClustered Index）中，叶子结点带有是数据的指针。

## 应用

MySQL数据库采用B+树，B树的范围查找需要遍历树，B+树只需要遍历叶子节点

# B*树

## 概念

- B树是B+树的变体，在B+树的**非根**和**非叶子结点**再增加指向**兄弟**的**指针**
- B树定义了非叶子结点关键字个数至少为**(2/3)**M，即块的最低使用率为2/3（代替B+树的1/2）

## 变化

### 分裂

当一个结点满时

1. 如果它的下一个兄弟结点未满，
    1. 那么将一部分数据移到兄弟结点中
    2. 在原结点插入关键字
    3. 修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；
2. 如果兄弟也满了
    1. 在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点
    2. 在父结点增加新结点的指针。

> [参考资料](https://zhuanlan.zhihu.com/p/52028653)

# 红黑树

弱平衡二叉查找树

## 特点

1、每个节点非红即黑； 
2、根节点是黑的； 
3、每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的； 
4、如果一个节点是红的,那么它的两儿子都是黑的； 
5、对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点； 
6、每条路径都包含相同的黑节点；