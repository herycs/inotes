# 树

## 基本概念

- n（n >= 0）个节点的有限集合，n=0 为空树

- n>0 时，集合满足以下条件

    - 1.有且仅有一个称为根的节点

        此节点无前驱，有0~多个后继

    - 2.除根节点外的n-1个结点可划分成m(m>=0)个互不相交的有限集（T1,T2,T3，...，Tm）

        每个节点有为一个树，称为根的子树，每颗子树的根节点有且仅有一个直接前驱，其前驱为根结点，同时可有0~多个直接后继节点。

## 树的表示法

- 图形表示法
- 嵌套集合表示法
- 广义表表示法
- 凹入表示法

## 树的基本术语

- 结点：包含一个数据元素及若干指向其子树的分支。
- 度：
    - 节点的度：节点拥有子树的个数
    - 树的度：树中所有节点的度的最大值。
- 叶子结点：
    - 度为0的节点
- 内部结点：度不为0，也称分支节点或非终结节点
- 孩子结点：结点的子树的跟称为该结点
- 双亲结点：结点是其子树的根称为该节点的孩子结点
- 双亲结点：结点是其子树的根的双亲，结点是其孩子的双亲
- 兄弟结点：同一双亲的孩子结点之间互称为兄弟结点
- 堂兄弟：双亲是兄弟或堂兄弟的节点间互称为堂兄弟节点
- 祖先节点：节点的祖先节点是指该结点的子树中的所有结点
- 结点的层次：根为第一层，根的孩子为第二层，...
- 树的层次：结点的层次的最大值，又称树的高度
- 前辈：层号比结点层号小的结点
- 后辈：层号比该结点层号大的结点
- 森林：m(m>=0)棵互不相交的树的集合
- 有序树：树中结点的各子树从左到右是有特定次序的称为有序树
- 无序树：树中结点的各子树从左到右是无特定次序的称为有序树

## 实现

### 概述

1. 二叉树
2. 二叉查找树
3. AVL树
4. 红黑树
5. B/B+/B*树

### 二叉树

没有什么特殊限制，保证其每个节点至多有2个子节点即可

### 二叉查找树 - 退化为链表

> 有称有序二叉查找树，无键值相等点

特点：保证其左右节点数值有序，左结点小于其根结点值，右结点值大于根节点值

- 简单来讲就是对任意（参与比较的结点都非空）结点有以下关系：leftData < rootData < rightData

优点：查找速度高于顺序查找，（检索次数少了）

缺点：特殊情况下，二叉查找树可能会单臂很长，这时其查找长度就会和线性查找逼近

> 单臂长举例
>
> ```shell
> 1
>   \
>     2
>       \
>        3
>         \
>          4
> ```
>
> 这种情况下和线性查找：1,2,3,4相比，效率并没有多少提高。

改进：上述单臂长的原因就是根节点始终没有变化过，但实际使用上并不能保证当前的根节点就是最优根节点。

### AVL树 - 绝对平衡

带平衡条件的二叉查找树

> 一般提供一个**平衡因子**，通过保证平衡因子在一定范围，从而保证树当前处于最优状态
>
> 平衡因子超过范围会对树进行旋转（简单来讲就是将树的根节点进行切换），从而尽量降低树的高度，减少查找次数。

优点：树的高度尽量降低，从而保证查找效率

缺点：维护高度需要对树进行旋转，这个过程是比较耗时的

应用：适用于查找删除次数少（调整树的次数尽量少），查询较多的情况（调整后的树查找效率还是比较可人的）

应用场景：查资料得知：Windows NT 内核中采用

改进：主要是修正树的次数过多影响性能，一个改进策略就是减弱对树高的判定从而减少修正次数

### 红黑树 - 相对平衡

**弱平衡**二叉查找树，每个节点添加一个标记颜色，通过对着色的限制确保没有一条路径长度比其他路径长2倍。

优点：通过检测颜色对树进行调整，相对于AVL树而言平衡的要求降低了一点

缺点：弱平衡，可能在某些情况下树并非是最优的查找树结构

应用

1、广泛用于C++的STL中，Map和Set都是用红黑树实现的； 
2、著名的Linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间； 
3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查； 
4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器； 
5、Java中TreeMap的实现；

### B树 - 复杂节点

结点的信息量不在单一只有本节点和子节点指针，结点的除了自己的节点数据还有子节点的索引，这样在查找的时候就可用更少的次数选对正确的路径（不许要读取子节点数据{减少了磁盘读取次数}，比对索引就可确认下一个前进的方向）

优点：减少IO次数,查找性能更优

缺点：结点存储的有数据，这样的话结点数据大索引的数量就会减少，同样读取这种结点也更加耗时一点

应用：磁盘文件组织，数据索引，数据库索引

改进：单个结点数据量大时索引会减少，且读取这种节点也更耗时（如果这个结点不是目标结点，这个耗时的IO就有点亏了）

### B+树 - 内存页管理

非叶子节点只有索引，叶子节点存储有数据

优点：结点的索引得到保证，大小也得到了保证，这样的话在节点IO层面每个节点的读取耗时相差不会很大

缺点

1. 主键非**有序**递增的，导致每次插入数据产生大量的**数据迁移**和**空间碎片**；
2. 主键是**有序**递增的，大量写请求的分布仍是随机的；

> [参考资料](https://www.cnblogs.com/tiancai/p/9024351.html)
>
> 推荐阅读：[分形树](https://www.open-open.com/news/view/e89fb0)