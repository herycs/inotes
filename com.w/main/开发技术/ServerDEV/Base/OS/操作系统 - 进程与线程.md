# 操作系统进程与线程

# 1.进程

## 1.1 概述

> 本质：正在执行的程序

- 产生由来：多道程序环境下，程序执行属于并发执行，失去了封闭性，并具有间断性，结果不可再现等特征。为使得程序可并发执行，引入“进程”。
- 伪并行：严格讲，某个瞬间CPU只能运行一个进程，但1s可运行多个，由此造成的并行错觉
- 地址空间（磁心映像core image,纪念磁芯存储器）：进程可进行读写操作的某个最小的存储位置（通常为0）到某个最大存储位置的列表
- 理解：容纳一个程序所需要所有信息的容器
- 特征：
  - 动态性：进程实质是进程实体执行的过程
  - 并发性：多个进程实体同时存在与内存空间中
  - 独立性：进程实体是一个能独立运行，独立获得资源和独立接受调度的基本单位。
  - 异步性：进程是按异步方式运行的

## 1.2 进程模型

> 计算机上所有可运行软件，通常包括操作系统，被组织为若干顺序进程（sequential process）,简称进程（process）

- 进程与程序：进程可以理解为一系列动作的总和，程序用适当形式描述的算法
- PCB：为使得并发执行的程序可独立运行，操作系统为进程配置专门的数据结构（Process Control Block，PCB)
- 进程实体：程序段，相关数据段，PCB
- 数据结构：
  - OS管理进程的数据结构一般分为以下部分
    - 内存--->内存表
    - 设备--->设备表
    - 文件--->文件表
    - 进程--->进程表
      - 进程表--->进程实体

## 1.3 进程创建

- 触发事件：

  > 系统初始化
  >
  > 指向了正在运行的进程所调用的进程创建系统调用
  >
  > 用户请求新建进程
  >
  > 批处理作业初始化

- UNIX系统中创建进程方法：fork

  - 级别：系统调用
  - 功能：创建一个与调用进程相同的副本（与父进程拥有相同的存储映像，环境字符串和打开文件）
  - 区别：子进程与父进程互不干扰，拥有不同的地址空间

- Windows中，CreateProcess除了创建同样需要把正确的程序装入新进程

## 父子进程

子进程继承父进程

- 用户号UIDs和用户组号GIDs
- 环境Environment
- 堆栈、共享内存
- 打开文件的描述符
- 执行时关闭（Close-on-exec）标志
- 信号（Signal）控制设定
- 进程组号
- 当前工作目录、根目录
- 文件方式创建屏蔽字
- 资源限制
- 控制终端

子进程独有

- 进程号PID
- 自己的文件描述符和目录流的拷贝
- 子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）
- 不继承异步输入和输出

> 总的来说，子进程从父进程继承了用户号和用户组号，用户信息，目录信息，环境（表），打开的文件描述符，堆栈，（共享）内存等。
> 经过fork()以后，父进程和子进程拥有相同内容的代码段、数据段和用户堆栈，就像父进程把自己克隆了一遍。事实上，父进程只复制了自己的PCB块。而代码段，数据段和用户堆栈内存空间并没有复制一份，而是与子进程共享。只有当子进程在运行中出现写操作时，才会产生中断，并为子进程分配内存空间。由于父进程的PCB和子进程的一样，所以在PCB中断中所记录的父进程占有的资源，也是与子进程共享使用的。这里的“共享”一词意味着“竞争”
> [原文链接](https://blog.csdn.net/feiyagogogo/article/details/79671398)

## 1.4 进程终止

- 触发条件：

  > 正常退出（自愿）
  >
  > 出错退出（自愿）
  >
  > 严重错误（非自愿）
  >
  > 被其它进程杀死（非自愿）

- 正常退出：任务完成告知操作系统

  - UNIX中：exit
  - Windows中：ExitProcess

- 出错退出：进程发现了严重错误

- 严重错误：进程引起的错误（一般是程序错误）

- 被其它进程杀死：进程执行系统调用

  - UNIX：kill
  - Windows：TerminateProcess

- 某些系统：进程终止时，无论自愿或者非自愿，由该进程创建的进程一律杀死

## 1.5 进程的层次结构

- UNIX中：有层次概念，进程和其子进程组成进程组
- Windows中：进程无层次概念，所有进程同步，父进程拥有控制自进程的令牌（可传送给其它进程）
- 某些系统中：父子进程有某种形式的关联

## 1.6 进程的状态

### 1.6.1 基础装态

- 常规状态：

  > 运行态(进程实际占用CPU)
  >
  > 就绪态(可运行，但因其他进程运行暂时停止）
  >
  > 阻塞态(除非外部事件发生否则不可运行)

- 阻塞：

  - 进程逻辑上不能继续运行，程序自身固有原因，例如：等待输入
  - 进程概念上不能继续运行，操作系统调用另一个进程占用了CPU

- 三态转换：

  > 运行-->阻塞（操作系统认为不能继续运行下去）
  >
  > 运行-->就绪（进程调度）
  >
  > 就绪-->运行（进程调度）
  >
  > 阻塞-->就绪（外部事件发生）

### 1.6.2 创建及终止状态

- 创建状态
  - 步骤：
    - 申请空白PCB
    - PCB中填写用于控制和管理进程的信息
    - 为进程分配资源
    - 进程转入就绪状态并插入就绪队列中
- 终止状态
  - 步骤：
    - 等待操作系统进行善后工作
    - 将PCB清零，并发还系统

### 1.6.3 挂起状态

- 挂起进入的原因

  - 终端用户需要将程序停下进行一些操作
  - 父进程的请求，父进程需要修改，查看或者协调子进程之间的状态
  - 负荷调节的需要，实时系统负荷较重时可将部分进程挂起，保证系统能正常运行
  - 操作系统需要，操作系统有时需要挂起某些进程对进程相关信息进行记录

- 引入原语后三态转换

  > 挂起原语：Suspend，激活原语：Active

  - 活动就绪--->静止就绪
  - 活动阻塞--->静止阻塞
  - 禁止就绪--->活动就绪
  - 禁止阻塞--->活动阻塞

- 引入挂起后的五态转换

  - NULL => 创建
  - 创建 =>活动就绪
  - 创建 =>静止就绪
  - 执行 =>终止

## 1.7 进程实现

- 原理：操作系统维护一个结构数组（进程表 process table），每个进程占用一个进程表项（也称为进程控制块）
- 表项包含信息：程序计数器，堆栈指针，内存分配状况，打开文件状态，账号，调度信息和其它进程状态转换时必须保存的信息

## 1.8 中断

- 中断向量（interrupt vector)：与IO类关联的一个位置（靠近内存底部）

- 所有中断从保存寄存器开始

- 流程：

  > - 1.硬件压入堆栈程序计数器，程序状态字，可能还有一个多个寄存器
  > - 2.硬件从中断向量装入新的程序计数器
  > - 3.汇编语言过程保存寄存器值
  > - 4.汇编语言过程设置新的堆栈
  > - 5.C中断服务例程运行（读和缓冲输入）
  > - 6.调度程序决定下一个将运行的程序
  > - 7.C过程返回至汇编代码
  > - 8.汇编语言过程开始运行新的当前进程

- 以上过程结束后，操作系统等待新命令，得到命令后则装入新的程序至内存，覆盖前一个程序

# 2.线程

> 传统操作系统中每个进程有一个地址空间和一个控制线程

## 2.1基本概念

- 使用原因：

> - 不必再考虑中断、定时器和上下文切换，只考察并行进程
> - 线程更加轻量级，更容易创建和撤销
> - 若存在大量的计算和IO处理，多个线程允许活动彼此重叠进行，以提高应用运行效率

## 2.2线程模型

> 基本概念：资源分组处理与执行

- 所有线程拥有完全一样的地址空间，共享全局变量

  - 进程中线程共享的内容：

    > 地址空间
    >
    > 全局变量
    >
    > 打开文件
    >
    > 子进程
    >
    > 即将发生的报警
    >
    > 信号与信号处理程序
    >
    > 账户信息

  - 线程独立内容：

    > 程序计数器
    >
    > 寄存器
    >
    > 堆栈
    >
    > 状态

- 线程状态：

  - 运行，阻塞，就绪，终止
  - 状态的转换与进程中的转换相同

- 线程能力：

  - 除了处理既定业务
  - 创建新的线程，线程间通常平等，thead_create返回线程标识符（线程名字）