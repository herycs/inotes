# 操作系统进程与线程

进程作为资源分配的基本单位

线程作为调度的基本单位

# 基本认识

## 概述

> 本质：正在执行的程序

产生由来：多道程序环境下，程序执行属于并发执行，失去了封闭性，并具有间断性，结果不可再现等特征。为使得程序可并发执行，引入“进程”。

伪并行：严格讲，某个瞬间CPU只能运行一个进程，但1s可运行多个，由此造成的并行错觉

地址空间（磁心映像core image,纪念磁芯存储器）：进程可进行读写操作的某个最小的存储位置（通常为0）到某个最大存储位置的列表

- 理解：容纳一个程序所需要所有信息的容器
- 特征：
  - 动态性：进程实质是进程实体执行的过程
  - 并发性：多个进程实体同时存在与内存空间中
  - 独立性：进程实体是一个能独立运行，独立获得资源和独立接受调度的基本单位。
  - 异步性：进程是按异步方式运行的

## 内容

### 进程的层次结构

- UNIX中：有层次概念，进程和其子进程组成进程组
- Windows中：进程无层次概念，所有进程同步，父进程拥有控制自进程的令牌（可传送给其它进程）
- 某些系统中：父子进程有某种形式的关联

### 模型

> 计算机上所有可运行软件，通常包括操作系统，被组织为若干顺序进程（sequential process）,简称进程（process）
>
> 进程实体：程序段 + 相关数据段 + PCB

- 进程与程序：进程可以理解为一系列动作的总和，程序用适当形式描述的算法
- PCB：为使得并发执行的程序可独立运行，操作系统为进程配置专门的数据结构（Process Control Block，PCB)

    数据结构：OS管理进程的数据结构一般分为以下部分
    - 内存--->内存表
    - 设备--->设备表
    - 文件--->文件表
    - 进程--->进程表
      - 进程表--->进程实体

### 原理

原理：操作系统维护一个结构数组（进程表 process table），每个进程占用一个进程表项（也称为进程控制块）

表项包含信息：程序计数器，堆栈指针，内存分配状况，打开文件状态，账号，调度信息和其它进程状态转换时必须保存的信息

## 进程状态

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200802170027700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDcwMTc5,size_16,color_FFFFFF,t_70)

### 进程终止

触发条件：

> 正常退出（自愿）
>
> 出错退出（自愿）
>
> 严重错误（非自愿）
>
> 被其它进程杀死（非自愿）

正常退出：任务完成告知操作系统

- UNIX中：exit
- Windows中：ExitProcess

出错退出：进程发现了严重错误

严重错误：进程引起的错误（一般是程序错误）

被其它进程杀死：进程执行系统调用

- UNIX：kill
- Windows：TerminateProcess

某些系统：进程终止时，无论自愿或者非自愿，由该进程创建的进程一律杀死

### 基础状态

常规状态：

> 运行态(进程实际占用CPU)
>
> 就绪态(可运行，但因其他进程运行暂时停止）
>
> 阻塞态(除非外部事件发生否则不可运行)

阻塞：

- 进程逻辑上不能继续运行，程序自身固有原因，例如：等待输入
- 进程概念上不能继续运行，操作系统调用另一个进程占用了CPU

三态转换：

> 运行-->阻塞（操作系统认为不能继续运行下去）
>
> 运行-->就绪（进程调度）
>
> 就绪-->运行（进程调度）
>
> 阻塞-->就绪（外部事件发生）

#### 创建及终止状态

##### 创建状态

步骤：
- 申请空白PCB
- PCB中填写用于控制和管理进程的信息
- 为进程分配资源
- 进程转入就绪状态并插入就绪队列中

触发事件：

> 系统初始化
>
> 指向了正在运行的进程所调用的进程创建系统调用
>
> 用户请求新建进程
>
> 批处理作业初始化

UNIX系统中创建进程方法：fork

- 级别：系统调用
- 功能：创建一个与调用进程相同的副本（与父进程拥有相同的存储映像，环境字符串和打开文件）
- 区别：子进程与父进程互不干扰，拥有不同的地址空间

Windows中，CreateProcess除了创建同样需要把正确的程序装入新进程

##### 终止状态

步骤：
- 等待操作系统进行善后工作
- 将PCB清零，并发还系统

#### 挂起状态

挂起进入的原因

- 终端用户需要将程序停下进行一些操作
- 父进程的请求，父进程需要修改，查看或者协调子进程之间的状态
- 负荷调节的需要，实时系统负荷较重时可将部分进程挂起，保证系统能正常运行
- 操作系统需要，操作系统有时需要挂起某些进程对进程相关信息进行记录

引入原语后三态转换

> 挂起原语：Suspend，激活原语：Active

- 活动就绪--->静止就绪
- 活动阻塞--->静止阻塞
- 禁止就绪--->活动就绪
- 禁止阻塞--->活动阻塞

引入挂起后的五态转换

- NULL => 创建
- 创建 =>活动就绪
- 创建 =>静止就绪
- 执行 =>终止

### 父子进程

子进程继承父进程

- 用户号UIDs和用户组号GIDs
- 环境Environment
- 堆栈、共享内存
- 打开文件的描述符
- 执行时关闭（Close-on-exec）标志
- 信号（Signal）控制设定
- 进程组号
- 当前工作目录、根目录
- 文件方式创建屏蔽字
- 资源限制
- 控制终端

子进程独有

- 进程号PID
- 自己的文件描述符和目录流的拷贝
- 子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）
- 不继承异步输入和输出

> 总的来说，子进程从父进程继承了用户号和用户组号，用户信息，目录信息，环境（表），打开的文件描述符，堆栈，（共享）内存等。
> 经过fork()以后，父进程和子进程拥有相同内容的代码段、数据段和用户堆栈，就像父进程把自己克隆了一遍。事实上，父进程只复制了自己的PCB块。而代码段，数据段和用户堆栈内存空间并没有复制一份，而是与子进程共享。只有当子进程在运行中出现写操作时，才会产生中断，并为子进程分配内存空间。由于父进程的PCB和子进程的一样，所以在PCB中断中所记录的父进程占有的资源，也是与子进程共享使用的。这里的“共享”一词意味着“竞争”
> [原文链接](https://blog.csdn.net/feiyagogogo/article/details/79671398)

## 进程控制

### 如何实现

​	基于原语实现控制

### 原语

原语通过**关中断**确保进程的状态切换不被打扰

单处理系统中，这种情况下时钟中断也会被屏蔽，CPU发生时钟中断或者其他中断时才发生进程切换

#### 原语需要做的事

- 更新PCB信息
- PCB调整到合适队列
- 分配回收资源

#### 分类

创建原语：触发创建的事件

1. 用户登录：分时系统
2. 作业调度：多道批处理系统
3. 提供服务：用户向操作系统提出请求
4. 应用请求：用户应用程序提出请求

撤销原语
			正常结束
			异常结束
			外界干预

阻塞原语

唤醒原语

1. 等待队列中找到PCB
2. 将PCB从阻塞队列移除，设置状态为就绪
3. 将PCB插入到就绪队列

切换原语

### 中断

中断向量（interrupt vector)：与IO类关联的一个位置（靠近内存底部）

所有中断从保存寄存器开始

流程：

> - 1.硬件压入堆栈程序计数器，程序状态字，可能还有一个多个寄存器
> - 2.硬件从中断向量装入新的程序计数器
> - 3.汇编语言过程保存寄存器值
> - 4.汇编语言过程设置新的堆栈
> - 5.C中断服务例程运行（读和缓冲输入）
> - 6.调度程序决定下一个将运行的程序
> - 7.C过程返回至汇编代码
> - 8.汇编语言过程开始运行新的当前进程

以上过程结束后，操作系统等待新命令，得到命令后则装入新的程序至内存，覆盖前一个程序

## 进程通信

> 1. 共享内存 shared memory
> 2. 管道 pipe | 命名管道
> 3. 消息队列 message queue | 共享消息队列
> 4. 信号量 semaphore
> 5. 套接字 socket
> 6. 信号 signal

操作系统中的通信进程通信方式

### 共享内存

> 两种类型：
>
> - 内存映射（程之间通过映射同一个普通文件实现共享内存，通过mmap()系统调用实现。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read/write等文件操作函数。
>
> - 共享内存
>
>     IPC的共享内存指的是把所有的共享数据放在共享内存区域（IPC shared memory region），任何想要访问该数据的进程都必须在本进程的地址空间新增一块内存区域，用来映射存放共享数据的物理内存页面。

操作系统提供共享空间以及同步互斥工具（P,V操作）

#### 基于数据结构

低级通信，速度较低，速度和数据格式受限

#### 基于存储区

高级通信，速度较低，内存中划分共享存储给进程，由进程控制数据结构，存储位置

### 管道

用于连续读写的共享文件，也称pipe文件，内存中大小固定的缓冲区（内核缓冲区）

半双工，实时通信需要两个管道，对管道的访问互斥，数据以字符流的形式写入

若未写满则不需读，若未读完（一旦读完就抛弃，最多允许一个进程读），不允许写

管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。

#### 管道

有亲缘关系管道可通信，最后一个进程关闭对它的连接的时候会自动撤销

#### 命名管道

无关进程也可通信

拥有一个名字和相应的访问权限，通过mknode()系统调用或者mkfifo()函数来建立的。一旦建立，任何进程都可以通过文件名将其打开和进行读写，而不局限于父子进程，当然前提是进程对FIFO有适当的访问权。当不再被进程使用时，FIFO在内存中释放，但磁盘节点仍然存在。

### 消息传递

数据交互以格式化消息为基本单位，操作系统提供发送接收的原语

#### 直接通信

进程本身拥有消息缓冲队列用于存储信息，A-》B发消息，消息会挂载到B的消息队列上

#### 间接通信

共享信箱，进程去信箱取自己的消息

### 信号量

### 套接字

### 信号

信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。

Linux提供了几十种信号，分别代表着不同的意义。信号之间依靠他们的值来区分，但是通常在程序中使用信号的名字来表示一个信号。在Linux系统中，这些信号和以他们的名称命名的常量被定义在/usr/includebitssignum.h文件中。通常程序中直接包含<signal.h>就好。

信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互。内核也可以利用信号来通知用户空间的进程来通知用户空间发生了哪些系统事件。信号事件有两个来源：

1）硬件来源，例如按下了cltr+C，通常产生中断信号sigint

2）软件来源，例如使用系统调用或者命令发出信号。最常用的发送信号的系统函数是kill,raise,setitimer,sigation,sigqueue函数。软件来源还包括一些非法运算等操作。

一旦有信号产生，用户进程对信号产生的相应有三种方式：

1）执行默认操作，linux对每种信号都规定了默认操作。

2）捕捉信号，定义信号处理函数，当信号发生时，执行相应的处理函数。

3）忽略信号，当不希望接收到的信号对进程的执行产生影响，而让进程继续执行时，可以忽略该信号，即不对信号进程作任何处理。

# 线程

> 传统操作系统中每个进程有一个地址空间和一个控制线程

## 基本概念

使用原因：

> - 不必再考虑中断、定时器和上下文切换，只考察并行进程
> - 线程更加轻量级，更容易创建和撤销
> - 若存在大量的计算和IO处理，多个线程允许活动彼此重叠进行，以提高应用运行效率

## 线程模型

> 基本概念：资源分组处理与执行

所有线程拥有完全一样的地址空间，共享全局变量

进程中线程共享的内容：

> 地址空间
>
> 全局变量
>
> 打开文件
>
> 子进程
>
> 即将发生的报警
>
> 信号与信号处理程序
>
> 账户信息

线程独立内容：

> 程序计数器
>
> 寄存器
>
> 堆栈
>
> 状态

线程状态：

- 运行，阻塞，就绪，终止
- 状态的转换与进程中的转换相同

线程能力：

- 除了处理既定业务
- 创建新的线程，线程间通常平等，thead_create返回线程标识符（线程名字）

## 模型

1-1

一个用户线程映射为一个操作系统内核线程

N-1

多个用户线程映射为一个操作系统内核线程

N-N

多个用户线程映射为多个操作系统内核线程

# 其他

## 管程

为了易于编写正确的程序，使用高级原语，管程

内容：过程 + 变量 + 数据结构等构成的一个模块

进程可以在任何需要的时候调用管程（说直白点就是封装了对数据的操作，通过确保对管程的调用是互斥的实现并发情况下的安全操作）

这个是个编译级别概念，需要编译器能识别，并对互斥做出安排

例如：Synchroized中的操作方法前后,monitorenter, monitorexit

## 协程

协程，又称微线程，纤程。英文名Coroutine。

协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

## 守护线程

服务于其他线程的线程，例如JVM中的守护线程
