# 结构型模式

composite：描述了如何构造一个类层次式结构，这一结构由两种类型的对象（基元对象和组合对象）所对应的类构成

Flywight：强调对象共享机制主要强调对象的空间效率，生成很多较小对象

Facade：描述如何用多个对象描述系统

Decorator：描述如何动态的为对象添加职责，采用递归方式组合对象，从而允许你添加任意多的对象职责。

## 适配器模式

目标类+适配者+适配器

意图：将一个类的接口转换成客户希望的另外一个接口。 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

别名：包装器，wapper

适用性：

- 你想使用一个已经存在的类，而它的接口不符合你的需求。
- 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。
- （仅适用于对象 A d a p t e r）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。

效果：

类适配器

- 用一个具体的 A d a p t e r类对A d a p t e e和Ta rg e t进行匹配。结果是当我们想要匹配一个类以 及所有它的子类时，类A d a p t e r将不能胜任工作。
- 使得A d a p t e r可以重定义A d a p t e e的部分行为，因为A d a p t e r是A d a p t e e的一个子类。
- 仅仅引入了一个对象，并不需要额外的指针以间接得到 a d a p t e e。

对象适配器

- 允许一个A d a p t e r与多个A d a p t e e—即A d a p t e e本身以及它的所有子类（如果有子类的话）—同时工作。A d a p t e r也可以一次给所有的A d a p t e e添加功能。
- 使得重定义A d a p t e e的行为比较困难。这就需要生成 A d a p t e e的子类并且使得A d a p t e r引用，这个子类而不是引用A d a p t e e本身。

使用考虑因素

- 匹配程度
- 可插入的Adapter
- 双向适配器提供透明选择

实现：

- 抽象
- 代理
- 参数化的适配器

## 桥接模式

抽象类（扩充抽象类）+实现类（扩充实现类）

解耦抽象和实现，增加了实现类的组合

意图：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

别名：H a n d l e / B o d y

动机：当一个抽象可能有多个实现时，通常用继承来协调它们。

适用性：

- 不期望抽象和实现绑定
- 类的抽象和实现通过生成子类的方法进行扩充
- 对抽象的修改应该不影响客户
- 多个对象间共享

协作：Abstraction将client请求转发给Implementor

优点：

- 分离接口与实现
- 提高扩充性
- 实现细节对客户透明

## 组合模式

意图：将对象的组合表示为“部分-整体”的树型层次结构

动机：各个组件的组合使用

适用性：

- 想要表示对象的部分-整体的关系
- 希望用户忽略组合对象和单个对象的不同

效果：

- 定义了基本对象和组合对象的层次结构
- 简化客户代码，客户可以一致的使用组合结构和单个对象
- 更容易增加新类
- 设计一般化

实现：

- 显示父组件引用
- 共享组件
- 最大化Component接口
- 声明管理子部件的操作
- Component是否应该有个Component列表
- 子部件排序
- 使用高速缓冲提高性能
- 如何回收无用Component
- 组件存储使用什么数据结构，列表，数组和Hash表

## 装饰模式

抽象原型类（具体原型类）+抽象装饰类（具体装饰类）

不改动原有类的基础上对类进行增加功能

意图：动态地给一个对象添加一些额外的职责。就增加功能来说， D e c o r a t o r模式相比生成子类更为灵活。

别名：Wrapper

动机：有时我们希望给某个对象而不是整个类添加一些功能。

适用性：

-  在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
- 处理那些可以撤消的职责。
- 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

效果：

- 比静态继承更加灵活
- 避免层次较高类有过多特征

实现：

- 接口一致性
- 省略抽象的Decorator，若只需要添加一个职责
- 保持Component类的简单性
- 改变对象外壳和改变对象内核

## 外观模式

外观类+多个具体类

聚合操作为一体

意图：为子系统中的一组接口提供一个一致的界面， F a c a d e模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

动机：将一个系统划分成为若干个子系统有利于降低系统的复杂性。

适用性：

- 为复杂子系统提供简单接口
- 客户程序与抽象类的实现部分有很大的依赖性
- 构建层次的子系统

效果：

- 对客户屏蔽子系统组件
- 实现了子系统与客户之间的松耦合关系
- 如果应用需要，它并不限制他们使用子系统类

## 享元模式

抽象享元（具体享元）+享元工厂

增加了缓存的工厂方法

对象池

意图：运用共享技术有效地支持大量细粒度的对象。

动机：有些应用程序得益于在其整个设计过程中采用对象技术，但简单化的实现代价极大。

适用性：

- 一个应用程序使用了大量的对象。
- 完全由于使用大量的对象，造成很大的存储开销。
- 对象的大多数状态都可变为外部状态。
- 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
- 应用程序不依赖于对象标识。由于 F l y w e i g h t对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。

实现：

- 删除外部状态
- 管理共享对象

## 代理模式

被代理类+代理类

代理类的执行

意图：为其他对象提供一种代理以控制对这个对象的访问。

别名：Surrogate 

动机：对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。

适用性：

1. 远 程 代 理 （ Remote Proxy ） 为 一 个 对 象在 不 同 的 地 址 空间 提 供 局 部 代 表。NEXTSTEP[Add94] 使用N X P r o x y类实现了这一目的。Coplien[Cop92] 称这种代理为“大使”（A m b a s s a d o r）。

2. 虚代理（Virtual Proxy）根据需要创建开销很大的对象。在动机一节描述的 I m a g e P r o x y就是这样一种代理的例子。

3. 保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。例如，在 C h o i c e s操作系统[ C I R M 9 3 ]中K e m e l P r o x i e s为操作系统对象提供了访问保护。

4. 智能指引（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。

    它的典型用途包括：对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它 (也称为S m a r tP o i n t e r s[ E d e 9 2 ] )。

    当第一次引用一个持久对象时，将它装入内存。

    在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。

效果：

- 远程代理：隐藏一个对象存在于不同地址空间的事实
- 虚拟代理：按需创建对象
- Protection Proxies和Smart Reference都允许在访问一个对象时有一些附加的内务处理（Housekeeping task）
- 隐藏另一种称之为 c o p y - o n - w r i t e的优化方式，代理延迟这一拷贝过程，我们可以保证只有当这个对象被修改的时候才对它进行拷贝。 
