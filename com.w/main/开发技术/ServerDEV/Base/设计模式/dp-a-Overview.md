# Overview

> 设计模式的思想根源是(开闭)基本原则的宏观运用,本质上是没有任何模式的，发现模式的人永远是大师,而死守模式的人,最对只能是一个工匠

## 面向对象五大原则

单一职责原则（SRP）：只做一件事，高内聚，低耦合

开放封闭原则（OCP）：可开扩展不可修改，抽象化，多态是开闭原则关键

Liskov(里氏代换原则)(LSP)：出现父类的地方一定可以用子类替换（开闭原则的补充，对开闭原则实现抽象化的具体步骤规范）

依赖倒置原则(LOD)：依赖于抽象

接口隔离原则(ISP)：类之间的依赖应该建立在最小的接口上

> ARTHUR J.RIEL在《 OOD启示录》中所说的：“你并必须遵守这些原则，违背而且你也把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”

## 描述设计模式

1. ### 模式名和分类

2. ### 意图

3. ### 别名

4. ### 动机

5. ### 适用性

6. ### 结构

7. ### 参与者

8. ### 协作

9. ### 效果

10. ### 实现

11. ### 代码示例

12. ### 已知应用

13. ### 相关模式


## 组织

|      |      | 目的                                                  |                                                              |                                                              |
| ---- | ---- | ----------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|      |      | 创建型                                                | 结构性                                                       | 行为性                                                       |
| 范围 | 类   | Factory Method                                        | Adapter                                                      | Interpreter \| Template Method                               |
|      | 对象 | Abstract Factory \| Buider \| Prototypte \| Singleton | Adatper \| Bridge \| Composite \| Decorator \| Facade \| Fltwight \| Proxy | Chain of responsibility \| Command \| Iterator \| Mediator \| Memento \| Observer \| Sate \| Strategy \| Visitor |

创建型类模式将创建工作延迟到子类，创建型对象模式将创建工作延迟到另外对象

结构型类模式使用继承机制组织类，结构型对象模式描述对象组织方式

行为型类模式使用继承描述算法和控制流，行为型对象模式描述一组对象怎么协作完成单个对象无法完成的任务

其他分类方式：1.多个模式使用时绑定（可以理解为一定的套路）2.“相关模式“描述相互之间的引用组织设计模式

![image-20200828111201828](C:\Users\ANGLE0\AppData\Roaming\Typora\typora-user-images\image-20200828111201828.png)

## 设计模式解决设计问题

### 寻找合适的对象

设计模式帮助确定并不明显的抽象和描述这些抽象的对象

### 决定对象的粒度

对象的大小和数目变化极大，下至硬件，上自整个应用都能表示

而设计模式可以用于决定一个对象是什么

### 指定对象接口

当给对象发送请求时，所引起的具体操作既与请求本身有关又与接受对象有关。支持相同请求的不同对象可能对请求激发的操作有不同的实现。发送给对象的请求和它的相应操作在运行时刻的连接就称之为动态绑定(dynamic binding)。

设计模式通过确定接口的主要组成成分及经接口发送的数据类型，来帮助你定义接口。

### 描述对象的实现

抽象类

类继承和接口继承

类定义了对象的实现，定义的对象内部状态和操作的实现

接口定义了对象能响应的请求的集合

### 对接口编程而非实现

类继承是一个通过复用父类功能而扩展应用功能的基本机制。它允许你根据旧对象快速定义新对象。它允许你从已存在的类中继承所需要的绝大部分功能，从而几乎无需任何代价就可以获得新的实现。

只根据抽象类中定义的接口来操纵对象有以下两个好处：

1) 客户无须知道他们使用对象的特定类型，只须对象有客户所期望的接口。

2) 客户无须知道他们使用的对象是用什么类来实现的，他们只须知道定义接口的抽象类。

### 运用复用机制

继承和组合

#### 继承

如我们已解释过的，类继承允许你根据其他类的实现来定义一个类的实现。这种通过生成子类的复用通常被称为白箱复用(white-box reuse)。

对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。

继承常被认为“破坏了封装性”，编译时静态确定，父类实现中的任何变化必然会导致子类发生变化

一个可用的解决方法就是只继承抽象类，因为抽象类通常提供较少的实现。

#### 组合

对象组合是通过获得对其他对象的引用而在运行时刻动态定义的。

组合要求对象遵守彼此的接口约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和其他对象一起使用。

这还会产生良好的结果：因为对象只能通过接口访问，所以我们并不破坏封装性；只要类型一致，运行时刻还可以用一个对象来替代另一个对象；更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系。

#### 委托

使得组合和继承拥有同样的复用能力，两个对象处理一个请求，接受请求的对象将操作委托给它的代理者

应用：State，Strategy，Visitor

## 设计应该支持变化

1) 通过显式地指定一个类来创建对象 

在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。

要避免这种情况，应该间接地创建对象。

设计模式：Abstract Factory(3.1)，Factory Method(3.3)，P r o t o t y p e ( 3 . 4 )。

2) 对特殊操作的依赖 

当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把请求代码写死，你将可以在编译时刻或运行时刻很方便地改变响应请求的方法。

设计模式：Chain of Resposibility(5.1)，C o m m a n d ( 5 . 2 )。

3) 对硬件和软件平台的依赖 

外部的操作系统接口和应用编程接口 ( A P I )在不同的软硬件聚合实例平台上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。

设计模式：Abstract Factory(3.1)，B r i d g e ( 4 . 2 )。

4) 对对象表示或实现的依赖 

知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。

设计模式：Abstract Factory(3.1)，B r i d g e ( 4 . 2 )，M e m e n t o ( 5 . 6 )，P r o x y ( 4 . 7 )

5) 算法依赖 

算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。

设计模式： B u i l d e r ( 3 . 2 )，I t e r a t o r ( 5 . 4 )，S t r a t e g y ( 5 . 9 )，Template Method(5.10) ， Vi s i t o r ( 5 . 11 )

6) 紧耦合 

紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体。

松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。

设计模式： Abstract Factory(3.1) ，C o m m a n d ( 5 . 2 )，F a c a d e ( 4 . 5 )，M e d i a t o r ( 5 . 5 )，Observer(5.7) ，Chain of Responsibility(5.1)。

7) 通过生成子类来扩充功能 

通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销(初始化、终止处理等)。定义子类还需要对父类有深入的了解。如，重定义一个操作可能需要重定义其他操作。一个被重定义的操作可能需要调用继承下来的操作。并且子类方法会导致类爆炸，因为即使对于一个简单的扩充，你也不得不引入许多新的子类。

一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通过以新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中去。另一方面，过多使用对象组合会使设计难于理解。许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例进行组合来引入定制的功能。

设计模式：B r i d g e ( 4 . 2 )，Chain of Responsibility(5.1)，C o m p o s i t e ( 4 . 3 )，D e c o r a t o r ( 4 . 4 )，O b s e r v e r ( 5 . 7 )，S t r a t e g y ( 5 . 9 )。

8) 不能方便地对类进行修改 

有时你不得不改变一个难以修改的类。也许你需要源代码而又没有(对于商业类库就有这种情况 )，或者可能对类的任何改变会要求修改许多已存在的其他子类。设计模式提供在这些情况下对类进行修改的方法。

设计模式：A d a p t e r ( 4 . 1 )，D e c o r a t o r ( 4 . 4 )，Vi s i t o r ( 5 . 11 )。