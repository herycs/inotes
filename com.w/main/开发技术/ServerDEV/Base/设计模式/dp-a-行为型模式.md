# 行为型模式

封装变化

行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。这些模式刻划了在运行时难以跟踪的复杂的控制流。它们将你的注意力从控制流转移到对象间的联系方式上来。

## 责任链模式

意图：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

应根据普遍性 ( g e n e r a l i t y )即从最特殊到最普遍的顺序来组织帮助信息。

适用性：

- 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。
- 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
- 可处理一个请求的对象集合应被动态指定。

效果：

1. 降低耦合度 ：该模式使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道该请求会被“正确”地处理。接收者和发送者都没有对方的明确的信息，且链中的对象不需知道链的结构。

    结果是，职责链可简化对象的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。

2. 增强了给对象指派职责( R e s p o n s i b i l i t y )的灵活性 当在对象中分派职责时，职责链给你更多的灵活性。你可以通过在运行时刻对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。你可以将这种机制与静态的特例化处理对象的继承机制结合起来使用。

3. 不保证被接受，既然一个请求没有明确的接收者，那么就不能保证它一定会被处理 —该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理。

实现：

1. 实现后继者链
2. 连接后继
3. 表示请求
4. 在smalltalk中自动转发

## 命令模式

意图：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。

别名：动作( A c t i o n )，事务( Tr a n s a c t i o n )

动机：有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接受者的任何信息。

适用性：

- 抽象出待执行的动作以参数化某对象。
- 在不同的时刻指定、排列和执行请求。
- 支持取消操作。C o m m a n d的E x c u t e操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。
- 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。
- 用构建在原语操作上的高层操作构造一个系统。

实现：

-  一个命令对象应达到何种智能程度 
- 支持取消（u n d o）和重做（r e d o）
- 避免取消操作过程中的错误积累

## 解释器模式-类

意图：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

动机：如果一种特定类型的问题发生的频率足够高 , 那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器 , 该解释器通过解释这些句子来解决该问题。

适用性：

- 当有一个语言需要解释执行 , 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。
-  该文法简单对于复杂的文法
- 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的 

效果：

- 易于改变和扩展文法
- 也易于实现文法
- 复杂的文法难以维护
- 增加了新的解释表达式的方式

## 迭代子模式-对象

意图：提供一种方法顺序访问一个聚合对象中各个元素 , 而又不需暴露该对象的内部表示。、

别名：游标（C u r s o r）。

动机：一个聚合对象, 如列表(list), 应该提供一种方法来让别人可以访问它的元素，而又不需暴露它的内部结构.

效果：

- 它支持以不同的方式遍历一个聚合
- 迭代器简化了聚合的接口
- 在同一个聚合上可以有多个遍历

## 中介者模式-对象

意图：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

动机：面向对象设计鼓励将行为分布到各个对象中。

适用性：

- 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。
- 一个对象引用其他很多对象并且直接与这些对象通信 ,导致难以复用该对象。
- 想定制一个分布在多个类中的行为，而又不想生成太多的子类。

效果：

-  减少了子类生成
-  它将各C o l l e a g u e解耦
- 它简化了对象协议 
- 它对对象如何协作进行了抽象
- 它使控制集中化

## 备忘录模式-对象

意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

别名：To k e n

动机：有时有必要记录一个对象的内部状态。

效果：

- 保持封装边界，把可能很复杂的 O r i g i n a t o r内部信息对其他对象屏蔽起来
- 它简化了原发器
- 使用备忘录可能代价很高
- 定义窄接口和宽接口
- 维护备忘录的潜在代价

## 观察者模式

意图：定义对象间的一种一对多的依赖关系 ,当一个对象的状态发生改变时 , 所有依赖于它的对象都得到通知并被自动更新。

别名：依赖(Dependents), 发布-订阅( P u b l i s h - S u b s c r i b e )

动机：将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性。

适用性：

- 当一个抽象模型有两个方面 , 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
- 当对一个对象的改变需要同时改变其它对象 , 而不知道具体有多少对象有待改变。
- 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之 , 你不希望这些对象是紧密耦合的。

效果：

- 目标和观察者间的抽象耦合 
- 支持广播通信 
- 意外的更新

## 状态模式-对象

意图：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

别名：状态对象（Objects for States）

动机：考虑一个表示网络连接的类 T C P C o n n e c t i o n。

适用性：

- 一个对象的行为取决于它的状态 , 并且它必须在运行时刻根据状态改变它的行为。
- 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。

效果： 

- 它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来
- 它使得状态转换显式化
-  State对象可被共享

## 策略模式-对象

意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

别名：政策（P o l i c y）

动机：有许多算法可对一个正文流进行分行。将这些算法硬编进使用它们的类中是不可取的

适用性：

- 许多相关的类仅仅是行为有异。
- 需要使用一个算法的不同变体。
- 算法使用客户不应该知道的数据。
-  一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。

效果：

- 相关算法系列
-  一个替代继承的方法
- 消除了一些条件语句
- 实现的选择
- 客户必须了解不同的Strategy
- S t r a t e g y和C o n t e x t之间的通信开销
- 增加了对象的数目 

## 模板方法模式-类

意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 

适用性：

-  一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
- 控制子类扩展。

## 访问者模式-对象

意图：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

动机：考虑一个编译器，它将源程序表示为一个抽象语法树。

适用性：

-  一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。
- 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。

效果：

- 访问者模式使得易于增加新的操作
- 访问者集中相关的操作而分离无关的操作
- 增加新的C o n c r e t e E l e m e n t类很困难
- 通过类层次进行访问
- 累积状态
- 破坏封装



## 

## 