# ID生成器

## 特点

全局唯一

有序（非必要）

短

可用时间长

批量生产

QPS高

## 处理办法

1. 数据库ID
2. UUID
3. 获取当前时间
4. 类雪花算法

### 数据库ID

主库的性能是其一大限制

### UUID

Universally Unique Identifier，通用唯一识别码

递增性得不到保障

#### 编码规则

1）1~8位采用系统时间，在系统时间上精确到毫秒级保证时间上的惟一性；

2）9~16位采用底层的IP地址，在服务器集群中的惟一性；

3）17~24位采用当前对象的HashCode值，在一个内部对象上的惟一性；

4）25~32位采用调用方法的一个随机数，在一个对象内的毫秒级的惟一性。

通过以上4种策略可以保证惟一性。在系统中需要用到随机数的地方都可以考虑采用UUID算法

#### 分类

基于时间的UUID

基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。由于在算法中使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。但与此同时，使用MAC地址会带来安全性问题，这就是这个版本UUID受到批评的地方。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址－－Java的UUID往往是这样实现的（当然也考虑了获取MAC的难度）。

DCE安全的UUID

DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。

基于名字的UUID（MD5）

基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。

随机UUID

根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但随机的东西就像是买彩票：你指望它发财是不可能的。

基于名字的UUID（SHA1）

和基于名字的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。

### 获取当前时间

### SNOWFLAKE算法

时间戳-41bit + 工作机器ID-10bit + 序列号-12bit

高可用：同时支持2 ^ 10 = 1024个机器生成ID

ID自增：时间放在高位

## 方案讨论

### ID为何不能严格有序

因为各个机器保证不了时间同步，即使有NTP server，也保证不了ms内各个机器同步

### 时间回退了怎么办，比如人为修改了系统时间

每个机器记录生成的最后一个ID，新生成ID的时候，拿当前时间和最后一个ID解析出来的时间（高42位）进行对比，不合理就报错

### 其他优化

比如并发控制，CAS，锁等

### 单机能生成全局唯一id吗

不能，因为没有单机标识，无论时间戳，随机数，所有机器都是等价的
 MAC地址有用吗？有，但是MAC地址可以伪造，无法保证唯一
 所以一定要有一个分布式集群统一分配机器编号来保证

### 总结

本文主要介绍了ID生成器的一些思路，并且对SNOWFLAKE方法进行简单讲解，从64位的构成方式上进行调整，进行针对性的改动，适合自己的要求。来达到分布式ID生成器组件的各个要求。对于方案设计提出一些思路