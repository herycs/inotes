# 锁优化

## 锁消除

> [参考博客](https://yq.aliyun.com/articles/666316)

同步块不一定会被多个线程使用到，当只有一个线程使用同步块，这时再对进行加锁，解锁操作有些多此一举了，Java虚拟机JIT编译时通过上下文扫描，会除去不存在公共资源竞争的锁

## 粒度优化

### 锁细化

能不写在同步块里的就不要写在同步块里

大锁拆小锁，增加并行，减小竞争

#### 实例

ConcurrentHashMap

LongAdder

LongAdder 实现思路也类似ConcurrentHashMap，LongAdder有一个根据当前并发状况动态改变的Cell数组，Cell对象里面有一个long类型的value用来存储值;

- 开始**没有并发争用**的时候或者是cells数组正在初始化的时候，会使用**cas**来将值累加到成员变量的base上
- 在**并发争用**的情况下，LongAdder会初始化cells数组，在Cell数组中选定一个**Cell加锁**，数组有多少个cell，就允许同时有多少线程进行修改，最后将数组中每个Cell中的value相加，在加上base的值，就是最终的值；
- cell数组还能根据当前线程争用情况进行**扩容**，初始长度为2，每次扩容会增长一倍，直到扩容到**大于等于cpu数量**就不再扩容

这也就是为什么LongAdder比cas和AtomicInteger效率要高的原因，后面两者都是volatile+cas实现的，他们的竞争维度是1，LongAdder的竞争维度为“Cell个数+1”为什么要+1？因为它还有一个base，如果竞争不到锁还会尝试将数值加到base上

LinkedBlockingQueue

LinkedBlockingQueue也体现了这样的思想，在队列头入队，在队列尾出队，入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高；

### 锁粗化

例如，循环体中加锁，每次操作，都需要进入&退出临界区，这种情况下应当将锁放大，将这个循环锁起来，减少临界区的进退次数

### 读写分离

CopyOnWriteArrayList

CopyOnWriteArraySet

CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

CopyOnWrite并发容器用于读多写少的并发场景，因为，读的时候没有锁，但是对其进行更改的时候是会加锁的，否则会导致多个线程同时复制出多个副本，各自修改各自的；

### 读写锁

接口：ReadWriteLock

实现：并发包提供ReentrantReadWriteLock

状态设计：整型变量，高16位用于读状态记录，低16位用于写状态记录

- 写状态：当前状态 & 0x0000FFFF(获取)，当前状态+1（修改）
- 读状态：当前状态>>>16（获取），当前状态+1<<<16（修改）

写锁：支持重入的排它锁

读锁：支持重入的共享锁

锁降级：写锁降级--->读锁

## CAS&同步

## 消除伪共享

两个线程对毫不想干得两个变量的访问，但因为加载数据是以缓存行为单位的，导致A操作行的数据时，B需要等待A操作完（而这，本没有必要）

## 重入锁

> ReentrantlLock，但关键字synchronized支持隐式重入

重入：获取锁线程多次重入（每次获取，计数自增）

释放：（计数自减为0）锁释放

## 公平，非公平锁

公平锁：锁的获取遵循严格的先后限制

非公平锁：非严格显示，一个线程可能多次获取同一个锁（这会导致“饥饿”状态的出现）

默认采用：非公平锁，饥饿出现的是少数，大量并发情况下公平锁的上下文切换次数远高于非公平锁

