# IO

# 基础

## IO

> 单个的字节的移动

- 对交互性程序而言就是（in）输入参数+（out）返回结果
- 对操作文件的程序而言（in）读入数据+（out）输出到文件
- 对于基于网络的服务程序而言就是（in）接受请求+（out）做出响应

但总体而言还是IO，只不过做出的处理和追求的方面不一样

## 同步&异步

- 同步：调用等待结果，而后进行下一步
- 异步：调用不硬性等待返回，可以先做别的操作

## 阻塞&非阻塞

- 阻塞：运行等待处理，未完成前暂不返回
- 非阻塞：执行立刻要就结果，并反馈结果

> 严格来讲上述的概念解释并不严谨，可参考[知乎](https://www.zhihu.com/question/19732473/answer/241673170)

## BIO

> 传统javaio包，Block IO, 同步阻塞, 并发处理能力低

实例：

- Socket，OS 运行的线程数量是有限的，狼多肉少的环境，必然会有处于等待状态的，而等待的策略就是（阻塞）

适用：

- 服务端不活跃线程较多 ---> 单线程处理

多个线程链接，阻塞情况下不会处理客户端请求，这是不允许的

## NIO

> jdk1.4引入，None-Block IO，同步非阻塞 IO，基于 Reactor 模型
>
> - 原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。
> - 面向流 的 I/O 系统一次一个字节地处理数据。

- 一个连接并不是时时刻刻都处于数据传输过程，其实在大多数情况下还是处于空闲状态（但是却占用着线程），我们可以想想办法把这段空闲时间利用起来。

服务端NIO

```shell
轮询--->有没有链接
	|没有--->继续轮询
	|有--->是否有数据
        |没有--->继续轮询
        |有--->处理数据
```

## AIO

> jdk1.7引入

- 异步非阻塞 IO

    这种 IO 模型是由操作系统先完成了客户端请求处理再通知服务器去启动线程进行处理。**AIO 也称 NIO2.0**

## 区别&联系

- BIO （Blocking I/O）：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。
- NIO （New I/O）：同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I/O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。
- AIO （ Asynchronous I/O）：异步非阻塞I/O模型。异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。

## 适用场景

- BIO方式适用于**连接少**且**固定**的架构，这种方式对服务器资源要求比较高，并发局限于应用中，但程序直观简单易理解。
- NIO方式适用于**连接多**且连接比较**短**（轻操作）的架构，并发局限于应用中，编程比较复杂，JDK1.4开始支持。
- AIO方式适用于**连接多**且连接比较**长**（重操作）的架构，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。

# 流

## 体系

> 图片来自菜鸟教程

![图片来自菜鸟教程](https://img-blog.csdnimg.cn/20200610113019927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDcwMTc5,size_16,color_FFFFFF,t_70)

## 字符流、字节流

### 字节，字符

- Bit最小的二进制单位 ，取值0或者1
- Byte（字节）是计算机操作数据的最小单位由8位bit组成 取值（-128-127）
- Char（字符）是用户的可读写的最小单位，在Java里面由16位bit组成 取值（0-65535）

### 字节流

- 操作byte类型数据，主要操作类是OutputStream、InputStream的子类
- 不用缓冲区，直接对文件本身操作。

### 字符流

- 操作字符类型数据，主要操作类是Reader、Writer的子类
- 使用缓冲区缓冲字符，不关闭流就不会输出任何内容。

### 相互转换

- OutputStreamWriter：是Writer的子类，将输出的字符流变为字节流，即将一个字符流的输出对象变为字节流输出对象。
- InputStreamReader：是Reader的子类，将输入的字节流变为字符流，即将一个字节流的输入对象变为字符流的输入对象

# OS的IO模型

> linux

### 阻塞IO

- 当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。
- 当数据就绪之后，内核唤醒用户线程，并返回结果给用户线程，用户线程解除block状态。

### 非阻塞IO

- 当用户线程发起一个read操作后，立刻得到返回结果，要么成功要么失败。

### 多路复用IO

- 在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。
- 只需要使用一个线程就可以管理多个socket

    不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。

### 信号驱动IO

- 在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行。
- 当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。

### 异步IO模型

- 异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。

> 推荐[阅读](https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html)