# 语法糖

## 语法糖

### Java中语法糖原理、解语法糖

语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。

解语法糖

- Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。

### 常见语法糖原理：

#### switch 支持 String 与枚举

Java中的`switch`自身原本就支持基本类型。
- 比如`int`、`char`等。对于`int`类型，直接进行数值的比较。对于`char`类型则是比较其ascii码。所以，对于编译器来说，
- `switch`中其实只能使用整型，任何类型的比较都要转换成整型。比如`byte`。`short`，`char`(ackii码是整型)以及`int`。

String 的Switch

- 字符串的switch是通过`equals()`和`hashCode()`方法来实现的。

泛型
- `Code specialization`和`Code sharing`。
    - C++和C#是使用`Code specialization`的处理机制
    - Java使用的是`Code sharing`的机制。
- Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（`type erasue`）实现的。
- Java虚拟机：**需要在编译阶段通过类型擦除的方式进行解语法糖**
    - 类型擦除主要过程：
        -  1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。
        -  2.移除所有的类型参数。

#### 自动装箱与拆箱

- 自动装箱就是Java自动将原始类型值转换成对应的对象
- **装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。**

#### 方法变长参数

- 可变参数(`variable arguments`)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。

#### 枚举

- Java SE5提供了一种新的类型-Java的枚举类型，关键字`enum`可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。

#### 内部类

- 内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，`outer.java`里面定义了一个内部类`inner`，一旦编译成功，就会生成两个完全不同的`.class`文件了，分别是`outer.class`和`outer$inner.class`。所以内部类的名字完全可以和它的外部类名字相同。

#### 条件编译

> Java语法的条件编译，是通过判断条件为常量的if语句实现的。其原理也是Java语言的语法糖。根据if判断条件的真假，编译器直接把分支为false的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译，这与C/C++的条件编译相比，确实更有局限性。在Java语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。

- 让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。

####  断言

- assert`关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了`assert`关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关`-enableassertions`或`-ea`来开启。
- 其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行。

#### 数值字面量

- 在java 7中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。
- 编译器并不认识在数字字面量中的`_`，需要在编译阶段把他去掉

#### for-each

- for-each的实现原理其实就是使用了普通的for循环和迭代器。

#### try-with-resource

- 那些我们没有做的关闭资源的操作，编译器都帮我们做了。

#### Lambda表达式

- 实现方式其实是依赖了几个JVM底层提供的lambda相关api
- lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，编译器会把lambda表达式进行解糖，转换成调用内部api的方式。

本地变量类型推断、record