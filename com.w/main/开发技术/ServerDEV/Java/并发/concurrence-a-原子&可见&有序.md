# 并发情况下需要处理的问题

## 目标

原子性

可见性

有序性

## 一致性

### 问题背景

CPU的迅速发展处理速度的极大提高&多核CPU的出现，但随之而来的也是CPU处理速度和内存的IO速度严重不匹配

针对以上问题，引入和缓存技术，追加缓存的方式尽量提高性能，但又引发了新的问题，那就是缓存的的*一致性*

> 数据的读取由原有的直接去主存读取变成了拷贝到缓存中再从缓存中读取，并发情况下很容易出现数据不一致的问题，特别是有的缓存不止一级，这个问题就更加严重了

### 运行时的问题

程序的运行往往并不像程序员所写的那样去执行，一般都有**编译器的优化**&**处理器执行时的优化**，二者目的都是为了尽可能提高程序的执行效率，编译器注重代码层面的优化，处理器则更注重程序对硬件的利用率

#### 重排序

1. 编译器重排序（*编译器重排序层面*）
2. 指令级重排序（*处理器重排序层面*，现代处理器采用指令级并行技术，操作间无数据依赖，则可以调整操作指令执行顺序）
3. 内存系统重排序（*处理器重排序层面*，处理器使用缓存和读写缓冲区，这种情况下加载存储操作可能是乱序的）

需要注意的是：多个处理器操作的数据依赖性不被编译器和处理器考虑

这些优化也是引发不一致性的原因之一，但却又不能完全不让优化，资源是有限的尽可能提高对资源的利用率无可厚非

为了对这些优化进行一定的限制，以避免由于优化的操作影响程序的正确执行

而在Java中由JMM负责管控线程的本地内存（JMM中抽象概念，涵盖缓存，写缓冲区，寄存器，其他硬件和编译器优化）到主内存间的数据传递过程

#### JMM应对策略

提供内存屏障（Memory Barries），禁止一些特定类型的（编译器，处理器）重排序

#### 处理器重排序规则

| 处理器    | Load-Load | Load-Store | Store-Store | Store-Load | 数据依赖 |
| --------- | --------- | ---------- | ----------- | ---------- | -------- |
| SPARC-TSO | N         | N          | N           | Y          | N        |
| x86       | N         | N          | N           | Y          | N        |
| IA64      | Y         | Y          | Y           | Y          | N        |
| PowerPC   | Y         | Y          | Y           | Y          | N        |

内存屏障：Load=>确保数据的装载，Store=>确保数据刷新（缓存数据刷新到主内存，也就是保证此数据对处理器可见）

#### 内存屏障类型

LoadLoad, LoadStore, StoreStore, StoreLoad

示例：Load1， LoadStore, Store1，Load1的数据装载先于Store1的数据刷新

## 原子性

### 方式

- 锁+循环CAS
- JVM的CAS操作利用的是处理器提供的CMPXCHG指令实现

提供的工具

- jdk1.5开始，并发包中提供诸如：AtomicBoolean, AtomicInteger这样的原子性更新值的工具

### 处理器操作

- 总线锁

    处理器发出LOCK # 信号，收到信号的处理器的请求将被阻塞住

- 缓存锁定

    同一时刻确保对某个内存地址的操作是原子的

    内存区域若被处理器缓存在缓存行中，且在LOCK期间被锁定，当它执行锁操作写回到内存时，处理器并不声言LOCK #，而是修改内部的内存地址，并允许他的缓存一致性机制（阻止同时修改由两个以上的处理器缓存的内存区域数据，当其他处理器写会已被锁定的缓存行的数据时，会导致缓存行无效）来保证操作的原子性

> 特殊不可用缓存锁定的情况
>
> - 数据不能被缓存在处理器内部，操作数横跨多个缓存行
> - 处理器不支持缓存锁定

### 问题

ABA问题

- JDK中提供AtomicStampedReference，其中compareAndSet首先检查当前引用，标志是否等于预期引用，标志，都相等是会采用原子操作更新值

循环时间长开销大

- 处理器提供一个pause的指令，指令作用如下
    1. 延迟流水线执行指令，延迟时间取决于实现版本
    2. 避免退出循环时因为内存顺序冲突引起CPU流水线被清空

只能保障一个共享变量的原子操作

- 多个共享变量的原子操作保证

    1. 锁

    2. 多个共享变量变为1个共享变量

        利用jdk中提供AtomicReference保证引用对象之间的原子性，可将多个对象共享变量放置到一个对象中进行CAS操作

## 有序性

### JMM重排序规则

> jdk1.5开始采用JSR-133内存模型

#### happens-before

> 若存在A的结果对B可见则，AB操作必须有happens-before关系
>
> happens-before仅要求前一个操作（执行结果）对后一个操作可见，并不确保两个操作一定要先后执行

##### 相关规则

程序：线程中的每个操作happens-before于其任意后续操作

监视器锁规则：解锁happens-before于加锁

volatile变量：volatile域的写happens-before于读

传递：A happens-before B, B happens-before C，则A happens-before C

##### JMM的处理

会改变执行结果的重排序：JMM要求编译器，处理器必须禁止重排序操作

不会改变执行结果的重排序：JMM不做限制

#### as-if-serial

##### 语义

无论如何重排序，（单线程）操作结果不可被改变，多线程情况下结果就不得保证了

### 顺序一致性模型

JMM对正确同步的多线程程序提供保证：若程序是正确同步（广义，包括对常用同步原语的使用），程序的执行将具有顺序一致性。

##### 特征

1. 线程操作依据程序顺序执行
2. （无论同步与否）所有线程都只能看到一个单一的操作执行顺序（顺序模型中每个操作必须原子执行，且立刻对所有线程可见）

### 具体处理

#### 同步程序

JMM在进入和退出临界区时做一些操作，确保程序在和两个时间节点和顺序一致性模型的内存视图一样

#### 非同步程序

JMM提供最小安全性，确保线程读取到的值不会凭空生成（之前线程写入值或者是默认值0，null，false）

在堆上分配对象时，内存空间清零，分配对象，JMM内部会对上述两个操作进行同步

JMM：

- 不保证单线程执行顺序（存在重排序）
- JMM不保证所有线程的操作执行顺序一致（存在重排序）
- 不保证对对64位long型和double型**写**操作的原子性

顺序一致性模型：

- 保证单线程的执行顺序
- 保证所有线程所见顺序一致
- 保证对64位long型和double型读写操作具有原子性

JSR-l33之前：long/double类型的读写拆分为32位的**读写**

JSR-l33：64位long/double类型变量写操作拆分为两个32位**写**操作，任意读操作都要保证原子性va中的技术支持

## 保障基础

原子性

Synchroized----》两个高级的字节码指令`monitorenter`和`monitorexit`

可见性

JMM保证，volatile值修改后会被刷新到主存中，每次对这种类型值的读取都是先从主存读取

另外，Synchroized&final也可实现可见性

有序性

Synchroized&volatile

volatile禁止指令重排序

Synchroized确保代码块的访问是互斥的