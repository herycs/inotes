# 并发&应对

## 问题

### 丢失更新

A事务操作被B事务覆盖掉

### 不可重复读

事务AB，B操作了DML导致A两次数据读取结果不一致，与脏读区别，读到的是已提交的数据

1. 修改操作
2. 删除操作
3. 添加操作

2,3称为幻读

### 脏读

脏页：内存和磁盘的异步性引发，并不影响数据一致性

A操作，B读取，A回滚，那么这时B拿到的数据就是脏数据

## 策略

- locking 封锁
- timestamp 时间戳
- optimitic scheduler 乐观锁
- multi-version concurrency control 多版本并发控制

### locking

何时加锁，持续多久，何时解锁

三级封锁

一级：修改数据R前加X锁

二级：读前加S锁，修改数据R前加X锁，读后释放S锁

三级：读前加S锁，修改数据R前加X锁，事务结束释放S锁

### 活锁

由于调度或者优先级关系导致一直无法加锁成功，业务得不到处理

### 死锁

资源占用，相互等待导致都无法进行下一步

### 一致性locking

一次性将所有会操作的资源加锁，处理完再释放

### 顺序locking

预先对加锁对象规定加锁顺序，所有事务都以这个顺序加锁

问题：1.数据库对象多，且变化快，维持这样的加锁顺序非常困难，且成本高昂；2.有的锁请求依据事务会发生变动，很难预先确认加锁对象

## 死锁诊断和解除

### 超时法

存在误判，有的是执行超过了规定时间

### 等待图法

出现回路则发生死锁

## 两阶段协议

2PL TwoPhare Locking

1. 读写Data前加lock
2. 读写后事务不再获得任何锁

## 多粒度锁

加速流程：

1. 当前，检查显示冲突
2. 上级，检查冲突
3. 下级，检查冲突

## 意向锁

先加Node锁，Node.next锁

### IS

表示后继节点拟加S锁

### IX

表示后继节点拟加X锁

### SIX

先加S锁，再加IX锁

## 并发控制机制

### 时间戳

检查时间戳处理冲突

### 乐观控制法

提交时再检查

### 多的版本并发控制

快照处理冲突

处理流程：

1. T发出READ，返回Qk
2. T发出WRITE,
    1. TS < R - timestamp(Qk)，回滚T
    2. TS = W  timestamp(Qk)，覆盖Qk
3. 否则，创建新的Q版本

改进，对于只读事务使用多版本时间戳，对于更新事务使用2PL，这种混合机制称为MV2PL

### Cerify-lock验证锁

写事务希望提交，则需要获取到写锁的数据对象的验证锁，一旦获取到验证锁，系统就可以丢弃掉原值，代之以新值，而后释放C-lock，提交事务

