# 编译原理01

# 1.序

- 编译方式：解释和编译

- 编译过程：

  词法分析-->语法分析-->语义分析+中间代码生成-->代码优化-->目标代码生成

  贯穿始终：表格管理，出错管理

  目标程序代码形式：汇编语言形式，可重定位二进制代码形式，内存形式

# 2.上下文无关文法

## 2.1基本运算

- 符号串长度：|xxx| = 3, | ε | = 0

- 符号串连接：x=ab, y=dc, 则xy=abdc

- 符号串的幂运算：x^0 = ε，x^1 = x, x^2 = xx

- 符号串集合乘积：

  > A={aa, bb},  B={cc, dd}
  >
  > AB = {aacc, aadd, bbcc, bbdd}

- 符号串集合的幂运算：A={aa, bb}, A^0 = {ε}, A^1 = {aa, bb}, A^2 = {aaaa, aabb, bbaa, bbbb}

- 符号串集合的闭包：

  > 正则闭包：A^+ = A^1 ∪ A^2 ∪ ...
  >
  > 闭包：A^* = A^0 ∪ A^1 ∪ A^2 ∪ ...

## 2.2基本概念

- 文法：描述语言结构的形式规则

- 文法形式（乔姆斯基分类方法）：0型，1型，2型，3型

  > 0型：短语文法
  >
  > 1型：上下文有关文法
  >
  > 2型：上下文无关文法
  >
  > 3型：正规文法

- 规则（产生式）：定义语言语法的单位结构，符号->，由...组成 或 定义为...

- 推到：规则右部反复替换左部的过程，符号=>

- 语法树：语法结构的图形表示

## 2.3文法和形式语言

- 产生式：（A,  α ），A ->  α 

- 文法：G[S] = (VN, VT, P, S)

  > VN：非空又穷非终结符号集
  >
  > VT：非空又穷终结符号集
  >
  > V = VN ∪ VT：文法符号集
  >
  > P：产生式的又穷集
  >
  > > A -> α, A ∈ VN, α ∈(VN∪ VT)
  >
  > S：文法开始符号， S ∈ VN

- 推导与规约

  - G , x, y, A, β ∈ P, xAy -> xβy
    - xβy 是 xAy 的直接推导
    - xAy 是 xβy 的直接规约
  - 符号表示：0...n 步推导 =*=>. 1...n步推导 =+=>

- 句型和句子

  > V* = VN ∪ VT

  - G，有S=*=> α, α ∈ V\*, 则 α 是给定文法G的句型
  - G， 有S=+=> α, α ∈ VT\*, 则 α 是给定文法G的句子

- 语言

  - 文法G[S]产生的**所有**句子的集合，记L(G[S])

    L(G[S]) = { ω ∈ VT*, 且S=+=> ω }

- 规范推导与规范规约

  - 对于直接推导 xAy => xβy，y为终结符号串或空符号串，则此推导为规范推导（最右推导）
  - 对于直接规约 xβy =r=> xAy，y为终结符号串或空符号串，则此规约为规范推导（最左规约）
  - 拓展：每一步都是规范的直接推导，则称为推导为规范的，记 α1=+r=> αn,规范推导得规范句型，右句型

- 等价文法

  - 文法G1 G2不同， 但L(G1) = L(G2), 则G1与G2为等价文法

- 递归产生式与递归文法

  - 递归产生式（对于文法G(VN, VT, P, S），若A->α∈P
    - 且α=*=>xAy，A->α递归产生式
    - α=xAy，A->α直接递归产生式
  - 递归文法：含有递归产生式的文法
  - 直接递归文法：含有直接递归产生式的文法

- 短语，直接短语，句柄

  > 有文法=（VN, VT, P, S），且U∈VN，x, y, u ∈ V*

  - 短语：若S=*=> xUy=+=>xuy，u为句型xuy相对于U的短语
  - 直接短语：若S=*=>xUy=>xuy，u为句型xuy相对于U的直接短语
  - 句柄：句子的最左直接短语

- 文法二义性

  - 文法中有一个句子对应两颗不同语法树，一个句子有两个不同的最左（最右）推导

## 2.4证明

> 依据形式语言理论

- 给定文法，可唯一的确定其语言， G->L(G)
- 给定语言L, 确定不唯一文法， L->G1 | G2 |...

# 3.有穷自动机与正则表达式

## 3.1有限自动机

> 文法对应语言可用状态转换图接受（识别），有限自动机是对状态转换图形式化的结果

### 3.1.1确定有限自动机（Determnistic Finite Automata）

- 定义：DFA M(S ,  ∑, f, S0, F)

  > - S 非空状态集合，每个元素为一个状态
  > -  ∑ 有限输入字符集合
  > - f 转换函数，SX ∑到S的**单值**部分映射
  > - S0：唯一初始状态， S0 ∈ S
  > - F ：终止状态集合， F  ⊆  S（可空）
  > - DFA所能识别的所有字符串的全体称为能被DFA M 所接受的语言，记L(M)

- 特点：单值映射

### 3.1.2非确定有限自动机（Nondeterministic Finte Autoamta)

- 定义：NFA M(S ,  ∑, f, S0, F)

  > - S 非空状态集合，每个元素为一个状态
  > -  ∑ 有限输入字符集合
  > - f 转换函数，SX∑到2^s的**子集**的映象
  > - S0：非空初始状态集， S0 ∈ S
  > - F ：终止状态集合， F  ⊆  S（可空）

- 特点：多值映射

## 3.2非确定有限自动机NFA确定化

- 将非确定中的状态集用一个状态表示
- 原因：NFA初态不唯一，程序入口不唯一

### 3.2.1子集构造法

### 3.2.3状态概念

- 无关状态：
  - 多余状态：初态无法直接到达的状态
  - 死状态：某个状态Si, 转换到它自身后不能到终态
- 等价状态：Si 状态能导出的所有符号串集合记为L(Si), Si和Sj,有L(Si)=L(Sj)，则Si和Sj是等价状态
- 可区别状态：Si 和Sj 不等价

### 3.2.2NFA最小化

- 1.DFA状态集初始化， ∏  = (S-Z, Z)
- 2.Si和Sj经过同一输入到同组中，则可划分为同一状态
- 3.重复2，直到不能再划分
- 4.取任意态为代表，合并删除等价态
- 5.删去无关态



## 3.3状态集的三个重要运算

-  ε-闭包：状态I中任何状态可经过仍意一条 ε 达到的装态的集合,  ε-closure(I)
- a弧转换：状态I中任何状态可经过一条a弧到达的所有状态的集合， move(I, a)
- a弧转换的闭包：Ia =  ε-closure(moe(I, a))

## 3.4正规式与NFA的相互转换

- R=AB，i --AB--> j  =>  i --A--> K --B--> j
- R=A|B, i --A|B--> j => i --A-->j; i--B--> J
- R=A*，i --A*-->j => i -- ε--> K --ε--> j



# 4.自上而下语法分析

## 4.1消除左递归

- 直接左递归消除

  > 直接左递归改写为非直接左递归

  > 原左递归：P -> P  α |  β 
  >
  > 改写后：
  >
  > P ->  β P\`
  >
  > P\` -> α P\`|  ε 

- 间接左递归改为直接左递归

  > 将简介左递归改为直接左递归，再使用直接左递归消除的方法

- 消除文法中全部左递归的算法

  > 前提文法不含回路

  - 1.排列文法中非终结符（顺序任意）
  - 2.对每个非终结符号用排在它前面的其它非终结符号产生式表示出来，并消除其中的直接左递归
  - 3.化简2中表达式，去掉多余产生式

## 4.2 First集的构造

> G = （VT， VN， S，P)，为上下文无关文法

- X ∈ VN，

  > X -> a...或者X -> ε，则 X 加到 First（X）中

- Y ∈VN

  > X -> Y...,则把First(Y)中所有非 ε 元素加到 First(X) 中

- 所有First中都有 ε，则将  ε 加到 First(X) 中

## 4.3Fllow集的构造

- 文法开始符号S，则#加入到Follow(B)中
- A->  αBβ，则first( β )/{ε} ，则加入Fllow(B)中
- A-> αB 或 A-> αBβ且 ε ∈ First(β)，则First(A)加入Follow(B)

## 4.4 LL(1)

- 预测分析程序：确定的自定向下分析程序
- 要求：文法是LL(1)文法
- 构成：分析栈， 分析表，分析程序

### 4.4.1构造预测分析表

- 表示方式：矩阵，行——非终结符， 列——输入符号或#

  > 对于[U, a]，表示对非终结符 U，输入为 a 时，向下推导所应采取的产生式

- 操作：

  - 1.文法的每一个产生式A->α,执行2,3步
  - 2.终结符 a ∈ First(α), A->a加到[A, a]
  - 3.ε ∈ First(α)，b ∈ Fllow(A)，则A->α加到[A, b]

# 5.自下而上语法分析(“移进——规约”)

## 5.1终结符之间的规约优先级

- a优先级高于b：a ·> b，a先于b被规约
- a优先级高于b：a ·= b（这个符号是等号中间有一个点），a，b同时被规约
- a优先级高于b：a <· b，a后于b被规约

## 5.2 算符优先级

- a ·> b

  > G中有产生式：
  >
  > U-> ...Pb...，且 P=+=>...a
  >
  > 或 P =+=>...aV

- a <· b

  > G中有产生式：
  >
  > U-> ...aP...，且 P=+=>b...
  >
  > 或 P=+=>Vb...

- a ·= b（这个符号是等号中间有一个点）

  > G中有产生式:
  >
  > U->...ab...
  >
  > 或 U-> ...aVb...

## 5.3 FirstVT和LastVT集

## 5.3.1FirstVT

- FirstVT(P) = {a | P =+=> a... 或 P =+=> Qa...，a∈VT 而 Q∈VN}

- 算法实现：

  > > - 初始化数组F[U, a]，存放FirstVT(U)a ∈ FirstVT(U) ，则F[U，a] = 1， F[U，a] = 0
  > >
  > > - 初始化工作栈
  >
  > - 1.数组元素初始化为0
  >
  > - 2.找到文法中U->b...或U->VB的产生式，对应的F[U, b] =1
  >
  > - 3.F[U, b] = 1，符号对<U, b>入栈
  >
  > - 4.栈非空，栈顶弹出标记为<V, b>
  >
  >   > - 文法中有，U->V...的产生式，则b ∈ FirstVT(U)，F[U, b]=0,则置为F[U,b] = 1,<U,b>压栈
  >   >
  >   > - 重复4.直至栈空

## 5.3.2LastVT

- LastVT(P) = {a | P =+=> ...a 或 P =+=> ...Qa，a∈VT 而 Q∈VN}

## 5.4最左素短语

- 素短语：文法句型的短语，至少包含一个终结符，除它之外不再包含任何更小的素短语
- 最左素短语：任意句型最左端的素短语

## 5.5识别活前缀NFA

- 规范句型：LR分析过程中栈里的文法符号自底向上和剩余符号串分配上构成规范句型

- 活前缀：规范句型的一个前缀，且不含句柄之后的任何符号

- 项目：文法G，产生式右部添加"·"构成文法的一个项目（特别的对于ε，项目为A->.，其中A代表产生式左部)

- NFA构造原则：

  > NFA 的状态集：每个项目对应的状态组成
  >
  > 输入字符集合：文法中的非终结符，终结符，ε构成
  >
  > 初态：文法G[S]的扩广文法G[s\`]，有S\`->.S，S为初态
  >
  > 终态：同上，S\`->S.，则S为终态

- 算符优先分析法

## 5.6 LR分析法

- LR(k)分析法：L——自左向右扫描，	R——分析过程是构造最右推导逆过程（规范规约），k为预测符号个数