# network-链路层

> 校验和: 一个传输分组中比特错误
>
> 定时器: 检测超时重传分组
>
> 序号: 将发送方向接受方的数据分组按顺序编号
>
> 确认: 告诉发送方一个分组或一组分组接受完成
>
> 否认确认: 告诉发送方一个分组或一组分组接受**未正确接收**
>
> 窗口，流水线: 发送方的利用率可在一定操作模式下得到提高，窗口长度可依据双方接受能力，网络拥塞程度调整
>
> 多路访问协议: 多个发送/接收结点同时使用广播信道，协调它们共享一个信道的方式。

# 链路层概述

**链路层协议内容**

- 通过单段链路，点到点传送上层数据
- 链路两端结点间交互的帧格式，发送和接收帧时的操作

**两种网络链路类型**

- 点对点链路
- 广播链路

**链路层环境重要特点**

- 一条路径上的不同链路可运行不同的链路层协议
- 链路层协议提供的服务可能不同
- 通信环境较为简单

**数据链路层功能在哪里实现？**

网络适配器硬件：核心功能
驱动程序：链路层的SAP，与网络层的接口

**网络适配器及其协议栈的功能关系**

![image-20200509201059887](C:\Users\ANGLE0\AppData\Roaming\Typora\typora-user-images\image-20200509201059887.png)

![image-20200509203220212](C:\Users\ANGLE0\AppData\Roaming\Typora\typora-user-images\image-20200509203220212.png)

## 适配器

### 作用

网络接口板又称为通信适配器(adapter)或网络接口卡NIC (Network Interface Card)，简称“网卡”。

网卡与局域网之间的通信是通过**电缆**以串行方式进行的，而和计算机之间的通信是通过计算机主板上的**I/O总线**以**并行**传输方式进行的。 

### 重要功能

- 成帧
- 差错检测
- 链路接入
- 流量控制
- 媒体接入

## 链路层服务设计

### 成帧

如何将数据报封装成帧：帧的附加信息、帧定界方法

### 差错检测

检错的方法：奇偶校验、检验和、CRC
检错的实现：网卡上硬件设计
差错的定义：误比特率

### 可靠交付

无差错、不丢失、按序、不重复
机制：FEC、ARQ

### 流量控制

相邻发送和接收结点间的步调一致，流量不匹配将导致数据丢失

###  媒体访问

- 冲突的仲裁和解决
- 点到点链路：全双工（物理、逻辑链路设计）、半双工
- 广播共享链路：静态复用、动态媒体访问控制

## 协议/规程分类 

![image-20200509205405880](C:\Users\ANGLE0\AppData\Roaming\Typora\typora-user-images\image-20200509205405880.png)

## 服务实现

### 成帧

#### 概述

**原因**：非全局同步系统，需要从比特流中将传输的数据分离出来。

**方式**：通过在要传输的数据前面或后面添加特殊标记来实现数据的同步

常用方法：首尾定界符，前导同步序列。

**传输数据大小**

帧长越长信道利用率越高，但是出错的概率也越大。于是，每种链路层协议规定了所允许的最大传输单元MTU（帧的数据部分长度上限）

#### 面向字节的协议

- 每帧都看成是字节的集合
- 保留一组字符为控制字符
- 效率较低，目前已**很少使用**
- DLE字符的“转义”作用

**透明传输问题**

数据中有可能出现与帧定界相同的符号或序列，引起数据丢失。

```shell
传输的帧: [SOH        EOF           EOT]
实质帧的数据为：SOH到第二个EOF，但由于识别时以EOF为结束符，故识别出来的数据其实少了后面[EOF,EOF]的数据
```

**解决办法**：面向字符协议：字节填充技术

```shell
//还是上面的例子：
传输的帧:      [SOH        EOF           EOT]
填充后的帧: [SOH       ESCEOF           EOT]
```

#### 面向比特的协议

- 面向比特的协议把帧看成比特的集合

**实现**：透明传输：比特填充 (bit stuffing)法(用于发送前/接收后)

- 发送方：报文中5个连续1，插入0
- 接收方：收到5个连续1：后为0 ，去掉；为1，后为0，则帧结束；否则出错

### 差错检测和纠正技术

#### **差错检测**

EDC= 差错检测和纠错比特 (冗余)

D    = 数据由差错校验保护，可能包括首部字段

差错检测不是100%可靠!

- 协议可能漏掉某些差错，但是非常少
- 较大的EDC字段产生更好的检测和纠正

##### 奇偶校验

校验依据：判断传输的一组二进制数据中"1"的个数是奇数还是偶数

奇校验：如果以二进制数据中1的个数是奇数为依据，则是奇校验

偶校验：如果以二进制数据中1的个数是偶数为依据，则是偶校验

##### 检验和方法

发送数据时步骤

1. 把校验和字段设置为0；
2. 把需要校验的数据看成以16位为单位的数字组成，依次进行二进制反码求和；
3. 把得到的结果存入校验和字段中。（校验字段是反码的和）

接收数据时步骤

1. 把首部看成以16位为单位的数字组成，依次进行二进制反码求和，包括校验和字段；
2. 检查计算出的校验和的反码是否为0；（反码和加和的反码）
3. 如果等于0，说明被整除，校验和正确。否则，校验和就是错误的，协议栈要抛弃这个数据包。

与传统二进制不同

1. 都是无符号整数
2. 是求和不是异或，所以有进位
3. 最高位的进位回卷到最低位
4. 所以1111有可能是溢出，因此先取反后求和与先求和后取反，得到的结果是一样的

> [为什么用先反码后求和](https://blog.csdn.net/samaritan_infi/article/details/78884268)

##### 循环冗余检测(CRC)

**策略**

- 加检查位：在信息报文上加上一些检查位，构成一个特定的待传报文，使它能被一个事先约定的多项式（生成多项式）除尽。

- 多项式校验：接收方收到报文后，再用同样的生成多项式去除收到的报文多项式，可以除尽表示传输无误，否则不正确。 

**注意点**

循环冗余校验码除法计算过程中采用模2运算，即在运算过程中不存在进位、借位问题，数据只有0、1两个状态；

计算过程中的所有减法和加法都遵循异或规则；

够不够减的判定原则是数据位长是否相等，而非值的大小。

> 广泛应用于通信网络的链路层协议中，以硬件实现

CRC校验可以100％地检测出长度小于等于k（k为G（x）的阶数）的突发错误。所以CRC的生成多项式的阶数越高，那么误判的概率就越小。 

#### 纠正技术

| 技术                                    | 策略                                       | 效果           | 适用场合                                   |
| --------------------------------------- | ------------------------------------------ | -------------- | ------------------------------------------ |
| 检错重发(detect and retransmission)     | 检测到发送方报文受损，则通知发送方重传副本 | 差错率低效果好 | 合链路差错率很低的场合，如有线通信         |
| 前向纠错(Forward Error Correction, FEC) | 纠错通过额外信息“预先”进行                 | 时效性         | 适合对时间要求很高的场合，如航天和实时控制 |

### 可靠传输

#### 问题引入

- 理想信道的数据传输模型：信道可靠+缓存无限大

- 实际信道不能保证处理机速度匹配，又不能保证不出错！

解决办法：引入确认采用反馈机制调节发送速度

#### 设计可靠数据传输协议

##### SW0协议

> 信道不丢包但会出错的情况下：

**解决方案**

- 接到正确PKT，发送一个肯定确认(ACK)
- 收到错误PKT，发送一个否定确认(NAK)，重传原PKT
- 停止等待协议(stop-and-wait, SW)

> 实用中有不少漏洞

##### SW1协议

**问题**

有丢包引起协议死锁

**解决方案**

- 增加超时定时器
- 每发PKT，启动超时定时器，称为超时重传机制
- 重传时间略大于RTT

**问题**

确认分组丢失，出现了分组冗余

**解决方案**

- 增加一种新机制：发送序号
    - 要求：序号空间要较小，如：发送序号3 bit，在0~7间循环使用 

##### SW3协议

**问题**

发送方过早超收到重复的确认，无法分辨对应哪个分组

**解决方案**

- 增加确认序号机制，分辨出确认对应哪个分组

### 总结

**综合以上机制为SW协议，或自动重传请求(ARQ)**

使用上述的确认和重传机制，我们就可以在**不可靠的信道**或链路上实现**可靠的数据通信**。
这种可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest)。
ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 

分析ARQ协议的效率
协议效率=    工作时间内协议实际发送的数据量
                     工作时间内网络理论可以传输的数据量
ARQ协议效率=1/（1+2ɑ），其中ɑ=Tp/Tf>=1
