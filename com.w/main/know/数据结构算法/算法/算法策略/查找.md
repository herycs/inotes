# 顺序表

## 1.顺序查找

## 2.折半查找

## 3.索引查找

## 4.二分查找

```java
public int find(int[] nums, int target){
    if (nums == null || nums.length == 0) return -1;
    int left = 0;
    int right = nums.length - 1;
    while (left <= right){
        int middle = (left + right) / 2;
        if (nums[middle] == target){
            return middle;
        } else if (nums[middle] < target){
            left = middle + 1;
        } else {
            right = middle - 1;
        }
    }
    return -1;
}
```

# 散列

## 1.Hash函数的构造方法

## 1.1 基础概念

- hash构造原则，简单和均匀

    - 函数本身运算尽量简单
    - 散列地址范围内，且分布均匀，地址冲突尽可能少

- 常用构造方法

    - 除留余数法

        - 表长m,p为小于等于m的最大素数，hash函数为：H(key)=key%p

    - 数字分析法

        - 关键字集合中的每个关键字都是由s位数字组成，可预先估计每个关键字出现的频度时，分析关键字集中的全体，提取其分布平均值的若干位和他们的组合作为地址

    - 平方取中法

        > 整数相除运行时间相比于相乘运行时间要慢

        - 求关键字的平方值扩大近似数的差别，依据表长度取中间几位数作为hash函数值

    - 分段叠加法

        - 关键字分割成位数相同的几部分（最后一部分位数可以不同），取这几部分叠加，叠加和（舍去进位）作为散列地址

## 2.处理冲突

- 开放定址法
    - 线性探测再散列
    - 二次探测再散列
    - 随机探测再散列
- 链地址法
    - 所有具有冲突的关键字在同一个链表中

## 3.Hash表查找

# 图-查找

## 广度优先搜索

> 回答两类问题：
>
> - 节点A出发能到达B吗
> - 节点A出发前往B那条路径最短

使用队列作为辅助实现对图的广搜，但是需要标记当前节点的访问情况，避免循环入队列导致死循环

## 狄克斯特拉

> 带权值的图

算法步骤：

1. 找出最便宜的节点，最短时间可到达
2. 更新邻居节点的开销（对于邻居节点，是否有前往它们的更短路径）
3. 重复，直至所有节点都这么操作过了
4. 计算最终路径

约定：对于一个处理过的节点，不存在比这个节点更便宜的节点

限制：只适用于正权边的图，即就是每个边的代价都是正的（或者可以认为是同号的）

## bellman-ford algorithm

> 贝尔曼-福德算法